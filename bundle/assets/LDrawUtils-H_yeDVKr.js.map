{"version":3,"file":"LDrawUtils-H_yeDVKr.js","sources":["../../node_modules/three/examples/jsm/loaders/LDrawLoader.js","../../node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tSRGBColorSpace,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n/**\n * A loader for the LDraw format.\n *\n * [LDraw](https://ldraw.org/} (LEGO Draw) is an [open format specification]{@link https://ldraw.org/article/218.html)\n * for describing LEGO and other construction set 3D models.\n *\n * An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction\n * piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are\n * loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,\n * extract to a folder and point setPartsLibraryPath to it.\n *\n * Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses\n * are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies\n * into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads\n * several packed files. The official parts library is not included due to its large size.\n *\n * `LDrawLoader` supports the following extensions:\n * - !COLOUR: Color and surface finish declarations.\n * - BFC: Back Face Culling specification.\n * - !CATEGORY: Model/part category declarations.\n * - !KEYWORDS: Model/part keywords declarations.\n *\n * ```js\n * const loader = new LDrawLoader();\n * loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer\n * const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n */\nclass LDrawLoader extends Loader {\n\n\t/**\n\t * Constructs a new LDraw loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// this material type must be injected via setConditionalLineMaterial()\n\t\tthis.ConditionalLineMaterial = null;\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = null;\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\t/**\n\t * This method must be called prior to `load()` unless the model to load does not reference\n\t * library parts (usually it will be a model with all its parts packed in a single file).\n\t *\n\t * @param {string} path - Path to library parts files to load referenced parts from.\n\t * This is different from Loader.setPath, which indicates the path to load the main asset from.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the conditional line material type which depends on the used renderer.\n\t * Use {@link LDrawConditionalLineMaterial} when using `WebGLRenderer` and\n\t * {@link LDrawConditionalLineNodeMaterial} when using `WebGPURenderer`.\n\t *\n\t * @param {(LDrawConditionalLineMaterial.constructor|LDrawConditionalLineNodeMaterial.constructor)} type - The conditional line material type.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetConditionalLineMaterial( type ) {\n\n\t\tthis.ConditionalLineMaterial = type;\n\t\tthis.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This async method preloads materials from a single LDraw file. In the official\n\t * parts library there is a special file which is loaded always the first (LDConfig.ldr)\n\t * and contains all the standard color codes. This method is intended to be used with\n\t * not packed files, for example in an editor where materials are preloaded and parts\n\t * are loaded on demand.\n\t *\n\t * @async\n\t * @param {string} url - Path of the LDraw materials asset.\n\t * @return {Promise} A Promise that resolves when the preload has finished.\n\t */\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMaterials( materials );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LDraw asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\t// Initializes the materials library with default materials\n\t\t\tthis.addDefaultMaterials();\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LDraw data and returns the resulting group.\n\t *\n\t * @param {string} text - The raw VRML data as a string.\n\t * @param {function(Group)} onLoad - Executed when the loading/parsing process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( text, onLoad, onError ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} )\n\t\t\t.catch( onError );\n\n\t}\n\n\t/**\n\t * Sets the loader's material library. This method clears existing\n\t * material definitions.\n\t *\n\t * @param {Array<Material>} materials - The materials to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetMaterials( materials ) {\n\n\t\tthis.clearMaterials();\n\t\tthis.addMaterials( materials );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the loader's material library.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tclearMaterials() {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a list of materials to the loader's material library.\n\t *\n\t * @param {Array<Material>} materials - The materials to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterials( materials ) {\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Initializes the loader with default materials.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddDefaultMaterials() {\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets a map which maps referenced library filenames to new filenames.\n\t * If a fileMap is not specified (the default), library parts will be accessed by trial and\n\t * error in subfolders 'parts', 'p' and 'models'.\n\t *\n\t * @param {Object<string,string>} fileMap - The file map to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a single material to the loader's material library.\n\t *\n\t * @param {Material} material - The material to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a material for the given color code.\n\t *\n\t * @param {string} colorCode - The color code.\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the Material for the main LDraw color.\n\t *\n\t * For an already loaded LDraw asset, returns the Material associated with the main color code.\n\t * This method can be useful to modify the main material of a model or part that exposes it.\n\t *\n\t * The main color code is the standard way to color an LDraw part. It is '16' for triangles and\n\t * '24' for edges. Usually a complete model will not expose the main color (that is, no part\n\t * uses the code '16' at the top level, because they are assigned other specific colors) An LDraw\n\t *  part file on the other hand will expose the code '16' to be colored, and can have additional\n\t * fixed colors.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\t/**\n\t * Returns the material for the edges main LDraw color.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\tif ( this.ConditionalLineMaterial === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().' );\n\n\t\t\t}\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new this.ConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\n/**\n * Utility class for LDraw models.\n *\n * @three_import import { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n */\nclass LDrawUtils {\n\n\t/**\n\t * Merges geometries in the given object by materials and returns a new group object.\n\t * Use on not indexed geometries. The object buffers reference the old object ones.\n\t * Special treatment is done to the conditional lines generated by LDrawLoader.\n\t *\n\t * @param {Object3D} object - The object to merge.\n\t * @returns {Group} The merged object.\n\t */\n\tstatic mergeObject( object ) {\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const meshMaterialsId of meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const linesMaterialsId of linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const condLinesMaterialsId of condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"names":["FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","COLOR_SPACE_LDRAW","SRGBColorSpace","_tempVec0","Vector3","_tempVec1","ConditionalLineSegments","LineSegments","geometry","material","generateFaceNormals","faces","i","l","face","vertices","v0","v1","v2","_ray","Ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","scalar","hashRay","ray","hardEdges","hardEdgeRays","halfEdgeList","normals","rh1","rh2","info","d0","d1","tri","vertCount","i2","index","next","hash","rayHash","distances","found","halfEdge","key","queue","vertNormals","faceNormal","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","otherNext","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","LineParser","line","lineNumber","pos0","pos1","LDrawParsedCache","loader","original","result","fileName","triedLowerCase","locationState","subobjectURL","fileLoader","FileLoader","text","conditionalSegments","subobjects","materials","getLocalMaterial","colorCode","category","keywords","author","totalFaces","lines","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","startingBuildingStep","lineIndex","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","newKeywords","keyword","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","clone","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","LDrawPartsGeometryCache","parseCache","faceMaterials","processInfoSubobjects","subobject","promises","promise","subobjectInfo","error","group","Group","subobjectInfos","subobjectGroup","parentLineSegments","parentConditionalSegments","parentFaces","inverted","matrixScaleInverted","lineColorCode","ls","os","controlPoints","createObject","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","positions","quadArray","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","edgeMaterial","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","LDrawLoader","Loader","manager","MeshStandardMaterial","LineBasicMaterial","path","url","colorLineRegex","directive","onLoad","onProgress","onError","fileMap","matLib","color","finalMaterialPass","parentIsPassthrough","c","getMaterial","mat","lineParser","code","fillColor","edgeColor","alpha","isTransparent","luminance","finishType","name","parseLuminance","Color","conditionalEdgeMaterial","lum","model","stepNumber","LDrawUtils","object","extractGroup","isConditionalLine","newGeometry","originalPositions","originalNormals","numVertsGroup","vertStart","vertEnd","addGeometry","geometries","geoms","permuteAttribute","attribute","elemSize","verts","numVerts","meshGeometries","linesGeometries","condLinesGeometries","normalMatrix","Matrix3","groupIndex","mergedObject","meshMaterialsIds","meshMaterialsId","meshGeometry","mergedGeometry","mergeGeometries","linesMaterialsIds","linesMaterialsId","lineGeometry","condLinesMaterialsIds","condLinesMaterialsId","condLineGeometry","condLines"],"mappings":"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","x_google_ignoreList":[0,1]}