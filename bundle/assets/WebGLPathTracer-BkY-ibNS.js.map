{"version":3,"file":"WebGLPathTracer-BkY-ibNS.js","sources":["../../src/textures/ProceduralEquirectTexture.js","../../src/textures/GradientEquirectTexture.js","../../src/materials/fullscreen/ClampedInterpolationMaterial.js","../../src/utils/CubeToEquirectGenerator.js","../../src/core/WebGLPathTracer.js"],"sourcesContent":["import {\r\n\tClampToEdgeWrapping,\r\n\tColor,\r\n\tDataTexture,\r\n\tEquirectangularReflectionMapping,\r\n\tLinearFilter,\r\n\tRepeatWrapping,\r\n\tRGBAFormat,\r\n\tSpherical,\r\n\tVector2,\r\n\tFloatType\r\n} from 'three';\r\n\r\nconst _uv = new Vector2();\r\nconst _coord = new Vector2();\r\nconst _polar = new Spherical();\r\nconst _color = new Color();\r\nexport class ProceduralEquirectTexture extends DataTexture {\r\n\r\n\tconstructor( width = 512, height = 512 ) {\r\n\r\n\t\tsuper(\r\n\t\t\tnew Float32Array( width * height * 4 ),\r\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\r\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\r\n\t\t);\r\n\r\n\t\tthis.generationCallback = null;\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t\tconst { data, width, height } = this.image;\r\n\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\t_coord.set( width, height );\r\n\r\n\t\t\t\t_uv.set( x / width, y / height );\r\n\t\t\t\t_uv.x -= 0.5;\r\n\t\t\t\t_uv.y = 1.0 - _uv.y;\r\n\r\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\r\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\r\n\t\t\t\t_polar.radius = 1.0;\r\n\r\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst i4 = 4 * i;\r\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\r\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\r\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\r\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.generationCallback = other.generationCallback;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { Color, Vector3 } from 'three';\r\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\r\n\r\nconst _direction = new Vector3();\r\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\r\n\r\n\tconstructor( resolution = 512 ) {\r\n\r\n\t\tsuper( resolution, resolution );\r\n\r\n\t\tthis.topColor = new Color().set( 0xffffff );\r\n\t\tthis.bottomColor = new Color().set( 0x000000 );\r\n\t\tthis.exponent = 2;\r\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\r\n\r\n\t\t\t_direction.setFromSpherical( polar );\r\n\r\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\r\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\r\n\t\tthis.topColor.copy( other.topColor );\r\n\t\tthis.bottomColor.copy( other.bottomColor );\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { ShaderMaterial } from 'three';\n\n// Material that tone maps a texture before performing interpolation to prevent\n// unexpected high values during texture stretching interpolation.\n// Emulates browser image stretching\nexport class ClampedInterpolationMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tif ( this.uniforms ) {\n\n\t\t\tthis.uniforms.opacity.value = v;\n\n\t\t}\n\n\t}\n\n\tget saturation() {\n\n\t\treturn this.uniforms?.saturation?.value ?? 1;\n\n\t}\n\n\tset saturation( v ) {\n\n\t\tif ( this.uniforms?.saturation ) this.uniforms.saturation.value = v;\n\n\t}\n\n\tget contrast() {\n\n\t\treturn this.uniforms?.contrast?.value ?? 1;\n\n\t}\n\n\tset contrast( v ) {\n\n\t\tif ( this.uniforms?.contrast ) this.uniforms.contrast.value = v;\n\n\t}\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tsaturation: { value: 1 },\n\t\t\t\tcontrast: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float saturation;\n\t\t\t\tuniform float contrast;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\n\t\t\t\t\t// product saturation (1 = unchanged, 0 = grayscale, >1 = more vivid)\n\t\t\t\t\tfloat lum = dot( gl_FragColor.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n\t\t\t\t\tgl_FragColor.rgb = mix( vec3( lum ), gl_FragColor.rgb, saturation );\n\n\t\t\t\t\t// product contrast (1 = unchanged, >1 = more contrast)\n\t\t\t\t\tgl_FragColor.rgb = ( gl_FragColor.rgb - 0.5 ) * contrast + 0.5;\n\t\t\t\t\tgl_FragColor.rgb = clamp( gl_FragColor.rgb, 0.0, 1.0 );\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import {\r\n\tDataTexture,\r\n\tDataUtils,\r\n\tEquirectangularReflectionMapping,\r\n\tFloatType,\r\n\tHalfFloatType,\r\n\tLinearFilter,\r\n\tLinearMipMapLinearFilter,\r\n\tRGBAFormat,\r\n\tRepeatWrapping,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget,\r\n} from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport * as CommonGLSL from '../shader/common/index.js';\r\n\r\nclass CubeToEquirectMaterial extends ShaderMaterial {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tenvMap: { value: null },\r\n\t\t\t\tflipEnvMap: { value: - 1 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\r\n\r\n\t\t\t\tuniform samplerCube envMap;\r\n\t\t\t\tuniform float flipEnvMap;\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\t\t${ CommonGLSL.util_functions }\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\r\n\t\t\t\t\trayDirection.x *= flipEnvMap;\r\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\r\n\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t\tthis.depthWrite = false;\r\n\t\tthis.depthTest = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class CubeToEquirectGenerator {\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._quad = new FullScreenQuad( new CubeToEquirectMaterial() );\r\n\r\n\t}\r\n\r\n\tgenerate( source, width = null, height = null ) {\r\n\r\n\t\tif ( ! source.isCubeTexture ) {\r\n\r\n\t\t\tthrow new Error( 'CubeToEquirectMaterial: Source can only be cube textures.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst image = source.images[ 0 ];\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst quad = this._quad;\r\n\r\n\t\t// determine the dimensions if not provided\r\n\t\tif ( width === null ) {\r\n\r\n\t\t\twidth = 4 * image.height;\r\n\r\n\t\t}\r\n\r\n\t\tif ( height === null ) {\r\n\r\n\t\t\theight = 2 * image.height;\r\n\r\n\t\t}\r\n\r\n\t\tconst target = new WebGLRenderTarget( width, height, {\r\n\t\t\ttype: FloatType,\r\n\t\t\tcolorSpace: image.colorSpace,\r\n\t\t} );\r\n\r\n\t\t// prep the cube map data\r\n\t\tconst imageHeight = image.height;\r\n\t\tconst maxMip = Math.log2( imageHeight ) - 2;\r\n\t\tconst texelHeight = 1.0 / imageHeight;\r\n\t\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\r\n\r\n\t\tquad.material.defines.CUBEUV_MAX_MIP = `${ maxMip }.0`;\r\n\t\tquad.material.defines.CUBEUV_TEXEL_WIDTH = texelWidth;\r\n\t\tquad.material.defines.CUBEUV_TEXEL_HEIGHT = texelHeight;\r\n\t\tquad.material.uniforms.envMap.value = source;\r\n\t\tquad.material.uniforms.flipEnvMap.value = source.isRenderTargetTexture ? 1 : - 1;\r\n\t\tquad.material.needsUpdate = true;\r\n\r\n\t\t// save state and render the contents\r\n\t\tconst currentTarget = renderer.getRenderTarget();\r\n\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = true;\r\n\t\trenderer.setRenderTarget( target );\r\n\t\tquad.render( renderer );\r\n\t\trenderer.setRenderTarget( currentTarget );\r\n\t\trenderer.autoClear = currentAutoClear;\r\n\r\n\t\t// read the data back\r\n\t\tconst buffer = new Uint16Array( width * height * 4 );\r\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\r\n\t\trenderer.readRenderTargetPixels( target, 0, 0, width, height, readBuffer );\r\n\t\ttarget.dispose();\r\n\r\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// produce the data texture\r\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\r\n\t\tresult.minFilter = LinearMipMapLinearFilter;\r\n\t\tresult.magFilter = LinearFilter;\r\n\t\tresult.wrapS = RepeatWrapping;\r\n\t\tresult.wrapT = RepeatWrapping;\r\n\t\tresult.mapping = EquirectangularReflectionMapping;\r\n\t\tresult.needsUpdate = true;\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._quad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tPerspectiveCamera,\r\n\tScene,\r\n\tVector2,\r\n\tClock,\r\n\tNormalBlending,\r\n\tNoBlending,\r\n\tAdditiveBlending,\r\n\tDataTexture,\r\n\tDataUtils,\r\n\tFloatType,\r\n\tHalfFloatType,\r\n\tRGBAFormat,\r\n\tEquirectangularReflectionMapping,\r\n\tRepeatWrapping,\r\n\tClampToEdgeWrapping,\r\n\tLinearFilter\r\n} from 'three';\r\nimport { PathTracingSceneGenerator } from './PathTracingSceneGenerator.js';\r\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { GradientEquirectTexture } from '../textures/GradientEquirectTexture.js';\r\nimport { getIesTextures, getLights, getTextures } from './utils/sceneUpdateUtils.js';\r\nimport { ClampedInterpolationMaterial } from '../materials/fullscreen/ClampedInterpolationMaterial.js';\r\nimport { CubeToEquirectGenerator } from '../utils/CubeToEquirectGenerator.js';\r\n\r\nfunction supportsFloatBlending( renderer ) {\r\n\r\n\treturn renderer.extensions.get( 'EXT_float_blend' );\r\n\r\n}\r\n\r\nconst _resolution = new Vector2();\r\nexport class WebGLPathTracer {\r\n\r\n\tget multipleImportanceSampling() {\r\n\r\n\t\treturn Boolean( this._pathTracer.material.defines.FEATURE_MIS );\r\n\r\n\t}\r\n\r\n\tset multipleImportanceSampling( v ) {\r\n\r\n\t\tthis._pathTracer.material.setDefine( 'FEATURE_MIS', v ? 1 : 0 );\r\n\r\n\t}\r\n\r\n\tget transmissiveBounces() {\r\n\r\n\t\treturn this._pathTracer.material.transmissiveBounces;\r\n\r\n\t}\r\n\r\n\tset transmissiveBounces( v ) {\r\n\r\n\t\tthis._pathTracer.material.transmissiveBounces = v;\r\n\r\n\t}\r\n\r\n\tget bounces() {\r\n\r\n\t\treturn this._pathTracer.material.bounces;\r\n\r\n\t}\r\n\r\n\tset bounces( v ) {\r\n\r\n\t\tthis._pathTracer.material.bounces = v;\r\n\r\n\t}\r\n\r\n\tget filterGlossyFactor() {\r\n\r\n\t\treturn this._pathTracer.material.filterGlossyFactor;\r\n\r\n\t}\r\n\r\n\tset filterGlossyFactor( v ) {\r\n\r\n\t\tthis._pathTracer.material.filterGlossyFactor = v;\r\n\r\n\t}\r\n\r\n\tget samples() {\r\n\r\n\t\treturn this._pathTracer.samples;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._pathTracer.target;\r\n\r\n\t}\r\n\r\n\tget tiles() {\r\n\r\n\t\treturn this._pathTracer.tiles;\r\n\r\n\t}\r\n\r\n\tget stableNoise() {\r\n\r\n\t\treturn this._pathTracer.stableNoise;\r\n\r\n\t}\r\n\r\n\tset stableNoise( v ) {\r\n\r\n\t\tthis._pathTracer.stableNoise = v;\r\n\r\n\t}\r\n\r\n\tget isCompiling() {\r\n\r\n\t\treturn Boolean( this._pathTracer.isCompiling );\r\n\r\n\t}\r\n\r\n\tget productSaturation() {\r\n\r\n\t\treturn this._quad.material.saturation;\r\n\r\n\t}\r\n\r\n\tset productSaturation( v ) {\r\n\r\n\t\tthis._quad.material.saturation = v;\r\n\r\n\t}\r\n\r\n\tget productContrast() {\r\n\r\n\t\treturn this._quad.material.contrast;\r\n\r\n\t}\r\n\r\n\tset productContrast( v ) {\r\n\r\n\t\tthis._quad.material.contrast = v;\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\t// members\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._generator = new PathTracingSceneGenerator();\r\n\t\tthis._pathTracer = new PathTracingRenderer( renderer );\r\n\t\tthis._queueReset = false;\r\n\t\tthis._clock = new Clock();\r\n\t\tthis._compilePromise = null;\r\n\r\n\t\tthis._lowResPathTracer = new PathTracingRenderer( renderer );\r\n\t\tthis._lowResPathTracer.tiles.set( 1, 1 );\r\n\t\tthis._quad = new FullScreenQuad( new ClampedInterpolationMaterial( {\r\n\t\t\tmap: null,\r\n\t\t\ttransparent: true,\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tpremultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha,\r\n\t\t} ) );\r\n\t\tthis._materials = null;\r\n\r\n\t\tthis._previousEnvironment = null;\r\n\t\tthis._previousBackground = null;\r\n\t\tthis._internalBackground = null;\r\n\t\tthis._rasterEnvMap = null; // FloatType copy for scene.environment (raster PBR)\r\n\t\tthis._previousRasterEnvMapSource = null;\r\n\t\tthis._rasterEnvMapScheduled = false;\r\n\t\tthis._pendingMaterialIndexUpdate = null;\r\n\t\tthis._pendingGeometry = null;\r\n\r\n\t\t// options\r\n\t\tthis.renderDelay = 100;\r\n\t\tthis.minSamples = 5;\r\n\t\tthis.fadeDuration = 500;\r\n\t\tthis.enablePathTracing = true;\r\n\t\tthis.pausePathTracing = false;\r\n\t\tthis.dynamicLowRes = false;\r\n\t\tthis.lowResScale = 0.25;\r\n\t\tthis.renderScale = 1;\r\n\t\tthis.synchronizeRenderSize = true;\r\n\t\tthis.rasterizeScene = true;\r\n\t\tthis.renderToCanvas = true;\r\n\t\tthis.textureSize = new Vector2( 1024, 1024  );  // preview default; final render bumps to 4096\r\n\t\tthis.rasterizeSceneCallback = ( scene, camera ) => {\r\n\r\n\t\t\tthis._renderer.render( scene, camera );\r\n\r\n\t\t};\r\n\r\n\t\tthis.renderToCanvasCallback = ( target, renderer, quad ) => {\r\n\r\n\t\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\t\trenderer.autoClear = false;\r\n\t\t\tquad.render( renderer );\r\n\t\t\trenderer.autoClear = currentAutoClear;\r\n\r\n\t\t};\r\n\r\n\t\t// initialize the scene so it doesn't fail\r\n\t\tthis.setScene( new Scene(), new PerspectiveCamera() );\r\n\r\n\t}\r\n\r\n\tsetBVHWorker( worker ) {\r\n\r\n\t\tthis._generator.setBVHWorker( worker );\r\n\r\n\t}\r\n\r\n\tsetScene( scene, camera, options = {} ) {\r\n\r\n\t\tscene.updateMatrixWorld( true );\r\n\t\tcamera.updateMatrixWorld();\r\n\r\n\t\tconst generator = this._generator;\r\n\t\tgenerator.setObjects( scene );\r\n\r\n\t\tif ( this._buildAsync ) {\r\n\r\n\t\t\treturn generator.generateAsync( options.onProgress ).then( result => {\r\n\r\n\t\t\t\tthis._updateFromResults( scene, camera, result );\r\n\t\t\t\treturn this._deferredSceneUpdates().then( () => result );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst result = generator.generate();\r\n\t\t\tthis._updateFromResults( scene, camera, result );\r\n\t\t\tif ( result.needsMaterialIndexUpdate && result.geometry ) {\r\n\r\n\t\t\t\tthis._pathTracer.material.materialIndexAttribute.updateFrom( result.geometry.attributes.materialIndex );\r\n\r\n\t\t\t}\r\n\t\t\tthis.updateMaterials();\r\n\t\t\tthis.updateLights();\r\n\t\t\tthis.updateEnvironment();\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetSceneAsync( ...args ) {\r\n\r\n\t\tthis._buildAsync = true;\r\n\t\tconst result = this.setScene( ...args );\r\n\t\tthis._buildAsync = false;\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tsetCamera( camera ) {\r\n\r\n\t\tthis.camera = camera;\r\n\t\tthis.updateCamera();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Compile the path tracing material (e.g. after setScene) so the first frame doesn't do compile + path trace together.\r\n\t * Reduces GPU load on initial load. Returns a promise that resolves when compilation is done.\r\n\t */\r\n\tcompileAsync() {\r\n\r\n\t\treturn this._pathTracer.compileMaterial();\r\n\r\n\t}\r\n\r\n\tupdateCamera() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tcamera.updateMatrixWorld();\r\n\r\n\t\tthis._pathTracer.setCamera( camera );\r\n\t\tthis._lowResPathTracer.setCamera( camera );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateMaterials() {\r\n\r\n\t\tconst material = this._pathTracer.material;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst materials = this._materials;\r\n\t\tconst textureSize = this.textureSize;\r\n\r\n\t\t// reduce texture sources here - we don't want to do this in the\r\n\t\t// textures array because we need to pass the textures array into the\r\n\t\t// material target\r\n\t\tconst textures = getTextures( materials );\r\n\t\tmaterial.textures.setTextures( renderer, textures, textureSize.x, textureSize.y );\r\n\t\tmaterial.materials.updateFrom( materials, textures );\r\n\t\t// Copy shadow catcher reflection intensity from any floor material that uses it\r\n\t\tmaterial.shadowCatcherReflectionIntensity = 1.0;\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\t\tconst m = materials[ i ];\r\n\t\t\tif ( m.shadowReflectionCatcher && m.shadowCatcherReflectionIntensity != null ) {\r\n\t\t\t\tmaterial.shadowCatcherReflectionIntensity = m.shadowCatcherReflectionIntensity;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateLights() {\r\n\r\n\t\tconst scene = this.scene;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst material = this._pathTracer.material;\r\n\r\n\t\tconst lights = getLights( scene );\r\n\t\tconst iesTextures = getIesTextures( lights );\r\n\t\tmaterial.lights.updateFrom( lights, iesTextures );\r\n\t\tmaterial.iesProfiles.setTextures( renderer, iesTextures );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateEnvironment() {\r\n\r\n\t\tconst scene = this.scene;\r\n\t\tconst material = this._pathTracer.material;\r\n\r\n\t\tif ( this._internalBackground ) {\r\n\r\n\t\t\tthis._internalBackground.dispose();\r\n\t\t\tthis._internalBackground = null;\r\n\r\n\t\t}\r\n\r\n\t\t// update scene background\r\n\t\tmaterial.backgroundBlur = scene.backgroundBlurriness;\r\n\t\tmaterial.backgroundIntensity = scene.backgroundIntensity ?? 1;\r\n\t\tmaterial.backgroundRotation.makeRotationFromEuler( scene.backgroundRotation ).invert();\r\n\t\tif ( scene.background === null ) {\r\n\r\n\t\t\tmaterial.backgroundMap = null;\r\n\t\t\tmaterial.backgroundAlpha = 0;\r\n\r\n\t\t} else if ( scene.background.isColor ) {\r\n\r\n\t\t\tthis._colorBackground = this._colorBackground || new GradientEquirectTexture( 16 );\r\n\r\n\t\t\tconst colorBackground = this._colorBackground;\r\n\t\t\tif ( ! colorBackground.topColor.equals( scene.background ) ) {\r\n\r\n\t\t\t\t// set the texture color\r\n\t\t\t\tcolorBackground.topColor.set( scene.background );\r\n\t\t\t\tcolorBackground.bottomColor.set( scene.background );\r\n\t\t\t\tcolorBackground.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign to material\r\n\t\t\tmaterial.backgroundMap = colorBackground;\r\n\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t} else if ( scene.background.isCubeTexture ) {\r\n\r\n\t\t\tif ( scene.background !== this._previousBackground ) {\r\n\r\n\t\t\t\tconst background = new CubeToEquirectGenerator( this._renderer ).generate( scene.background );\r\n\t\t\t\tthis._internalBackground = background;\r\n\t\t\t\tmaterial.backgroundMap = background;\r\n\t\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.backgroundMap = scene.background;\r\n\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t}\r\n\r\n\t\t// update scene environment\r\n\t\tmaterial.environmentIntensity = scene.environment !== null ? ( scene.environmentIntensity ?? 1 ) : 0;\r\n\t\tmaterial.environmentSaturation = scene.userData?.environmentSaturation ?? 1;\r\n\t\tmaterial.environmentRotation.makeRotationFromEuler( scene.environmentRotation ).invert();\r\n\t\tif ( this._previousEnvironment !== scene.environment ) {\r\n\r\n\t\t\tif ( scene.environment !== null ) {\r\n\r\n\t\t\t\tif ( scene.environment.isCubeTexture ) {\r\n\r\n\t\t\t\t\tconst environment = new CubeToEquirectGenerator( this._renderer ).generate( scene.environment );\r\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( environment );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// TODO: Consider setting this to the highest supported bit depth by checking for\r\n\t\t\t\t\t// OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\r\n\t\t\t\t\t// the equirect uniform\r\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( scene.environment );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use sanitized env map for raster view so Infinity/NaN in raw HDR don't cause black materials.\r\n\t\t// Raster PBR (WebGLRenderer) often fails with HalfFloatType env maps; use a FloatType copy.\r\n\t\tconst sanitizedMap = material.envMapInfo.map;\r\n\t\tif ( scene.environment !== null && sanitizedMap ) {\r\n\r\n\t\t\tif ( sanitizedMap.type === HalfFloatType ) {\r\n\r\n\t\t\t\t// Reuse or create FloatType copy for raster view (deferred to avoid blocking first frame with CPU-heavy fromHalfFloat loop)\r\n\t\t\t\tif ( this._previousRasterEnvMapSource !== sanitizedMap && this._rasterEnvMap ) {\r\n\r\n\t\t\t\t\tthis._rasterEnvMap.dispose();\r\n\t\t\t\t\tthis._rasterEnvMap = null;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( ! this._rasterEnvMap ) {\r\n\r\n\t\t\t\t\tif ( ! this._rasterEnvMapScheduled ) {\r\n\r\n\t\t\t\t\t\tthis._rasterEnvMapScheduled = true;\r\n\t\t\t\t\t\tconst self = this;\r\n\t\t\t\t\t\tconst source = sanitizedMap;\r\n\t\t\t\t\t\tconst sc = scene;\r\n\t\t\t\t\t\trequestAnimationFrame( function buildRasterEnvMap() {\r\n\r\n\t\t\t\t\t\t\tself._rasterEnvMapScheduled = false;\r\n\t\t\t\t\t\t\tif ( self._previousRasterEnvMapSource !== source || self._rasterEnvMap ) return;\r\n\r\n\t\t\t\t\t\t\tconst { width, height, data } = source.image;\r\n\t\t\t\t\t\t\tconst stride = Math.floor( data.length / ( width * height ) );\r\n\t\t\t\t\t\t\tconst floatData = new Float32Array( width * height * 4 );\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < width * height; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tfloatData[ 4 * i + 0 ] = DataUtils.fromHalfFloat( data[ stride * i + 0 ] );\r\n\t\t\t\t\t\t\t\tfloatData[ 4 * i + 1 ] = DataUtils.fromHalfFloat( data[ stride * i + 1 ] );\r\n\t\t\t\t\t\t\t\tfloatData[ 4 * i + 2 ] = DataUtils.fromHalfFloat( data[ stride * i + 2 ] );\r\n\t\t\t\t\t\t\t\tfloatData[ 4 * i + 3 ] = stride >= 4 ? DataUtils.fromHalfFloat( data[ stride * i + 3 ] ) : 1.0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tself._rasterEnvMap = new DataTexture( floatData, width, height, RGBAFormat, FloatType, EquirectangularReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter );\r\n\t\t\t\t\t\t\tself._rasterEnvMap.needsUpdate = true;\r\n\t\t\t\t\t\t\tself._previousRasterEnvMapSource = source;\r\n\t\t\t\t\t\t\tsc.environment = self._rasterEnvMap;\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// This frame: raster may use HalfFloat (one-frame delay); path tracer uses envMapInfo.map as-is\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscene.environment = this._rasterEnvMap;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( this._rasterEnvMap ) {\r\n\r\n\t\t\t\t\tthis._rasterEnvMap.dispose();\r\n\t\t\t\t\tthis._rasterEnvMap = null;\r\n\t\t\t\t\tthis._previousRasterEnvMapSource = null;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tscene.environment = sanitizedMap;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._previousEnvironment = scene.environment;\r\n\t\tthis._previousBackground = scene.background;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\t_updateFromResults( scene, camera, results ) {\r\n\r\n\t\tconst {\r\n\t\t\tmaterials,\r\n\t\t\tgeometry,\r\n\t\t\tbvh,\r\n\t\t\tbvhChanged,\r\n\t\t\tneedsMaterialIndexUpdate,\r\n\t\t} = results;\r\n\r\n\t\tthis._materials = materials;\r\n\r\n\t\tconst pathTracer = this._pathTracer;\r\n\t\tconst material = pathTracer.material;\r\n\r\n\t\tif ( bvhChanged ) {\r\n\r\n\t\t\tmaterial.bvh.updateFrom( bvh );\r\n\t\t\tmaterial.attributesArray.updateFrom(\r\n\t\t\t\tgeometry.attributes.normal,\r\n\t\t\t\tgeometry.attributes.tangent,\r\n\t\t\t\tgeometry.attributes.uv,\r\n\t\t\t\tgeometry.attributes.color,\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t// Defer material index + materials/lights/env to staggered rAFs (reduces GPU exhaustion on initial load)\r\n\t\tif ( needsMaterialIndexUpdate ) {\r\n\r\n\t\t\tthis._pendingMaterialIndexUpdate = true;\r\n\t\t\tthis._pendingGeometry = geometry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._pendingMaterialIndexUpdate = false;\r\n\t\t\tthis._pendingGeometry = null;\r\n\r\n\t\t}\r\n\r\n\t\t// save previously used items\r\n\t\tthis._previousScene = scene;\r\n\t\tthis.scene = scene;\r\n\t\tthis.camera = camera;\r\n\r\n\t\tthis.updateCamera();\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n\t// Staggered updates across two frames: rAF1 = material index + materials + lights; rAF2 = env. Reduces GPU exhaustion on initial load.\r\n\t_deferredSceneUpdates() {\r\n\r\n\t\tconst self = this;\r\n\t\treturn new Promise( ( resolve ) => {\r\n\r\n\t\t\trequestAnimationFrame( () => {\r\n\r\n\t\t\t\tif ( self._pendingMaterialIndexUpdate && self._pendingGeometry ) {\r\n\r\n\t\t\t\t\tself._pathTracer.material.materialIndexAttribute.updateFrom( self._pendingGeometry.attributes.materialIndex );\r\n\t\t\t\t\tself._pendingMaterialIndexUpdate = false;\r\n\t\t\t\t\tself._pendingGeometry = null;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tself.updateMaterials();\r\n\t\t\t\tself.updateLights();\r\n\r\n\t\t\t\trequestAnimationFrame( () => {\r\n\r\n\t\t\t\t\tself.updateEnvironment();\r\n\t\t\t\t\tresolve();\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\trenderSample() {\r\n\r\n\t\tconst lowResPathTracer = this._lowResPathTracer;\r\n\t\tconst pathTracer = this._pathTracer;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst clock = this._clock;\r\n\t\tconst quad = this._quad;\r\n\r\n\t\tthis._updateScale();\r\n\r\n\t\tif ( this._queueReset ) {\r\n\r\n\t\t\tpathTracer.reset();\r\n\t\t\tlowResPathTracer.reset();\r\n\t\t\tthis._queueReset = false;\r\n\r\n\t\t\tquad.material.opacity = 0;\r\n\t\t\tclock.start();\r\n\r\n\t\t}\r\n\r\n\t\t// render the path tracing sample after enough time has passed\r\n\t\tconst delta = clock.getDelta() * 1e3;\r\n\t\tconst elapsedTime = clock.getElapsedTime() * 1e3;\r\n\t\tif ( ! this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime && ! this.isCompiling ) {\r\n\r\n\t\t\tpathTracer.update();\r\n\r\n\t\t}\r\n\r\n\t\t// when alpha is enabled we use a manual blending system rather than\r\n\t\t// rendering with a blend function\r\n\t\tpathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || ! supportsFloatBlending( renderer );\r\n\t\tlowResPathTracer.alpha = pathTracer.alpha;\r\n\r\n\t\tif ( this.renderToCanvas ) {\r\n\r\n\t\t\tconst renderer = this._renderer;\r\n\t\t\tconst minSamples = this.minSamples;\r\n\r\n\t\t\tif ( elapsedTime >= this.renderDelay && this.samples >= this.minSamples ) {\r\n\r\n\t\t\t\tif ( this.fadeDuration !== 0 ) {\r\n\r\n\t\t\t\t\tquad.material.opacity = Math.min( quad.material.opacity + delta / this.fadeDuration, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tquad.material.opacity = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render the fallback if we haven't rendered enough samples, are paused, or are occluded\r\n\t\t\tif ( ! this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1 ) {\r\n\r\n\t\t\t\tif ( this.dynamicLowRes && ! this.isCompiling ) {\r\n\r\n\t\t\t\t\tif ( lowResPathTracer.samples < 1 ) {\r\n\r\n\t\t\t\t\t\tlowResPathTracer.material = pathTracer.material;\r\n\t\t\t\t\t\tlowResPathTracer.update();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst currentOpacity = quad.material.opacity;\r\n\t\t\t\t\tquad.material.opacity = 1 - quad.material.opacity;\r\n\t\t\t\t\tquad.material.map = lowResPathTracer.target.texture;\r\n\t\t\t\t\tquad.render( renderer );\r\n\t\t\t\t\tquad.material.opacity = currentOpacity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! this.dynamicLowRes && this.rasterizeScene || this.dynamicLowRes && this.isCompiling ) {\r\n\r\n\t\t\t\t\tthis.rasterizeSceneCallback( this.scene, this.camera );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( this.enablePathTracing && quad.material.opacity > 0 ) {\r\n\r\n\t\t\t\tif ( quad.material.opacity < 1 ) {\r\n\r\n\t\t\t\t\t// use additive blending when the low res texture is rendered so we can fade the\r\n\t\t\t\t\t// background out while the full res fades in\r\n\t\t\t\t\tquad.material.blending = this.dynamicLowRes ? AdditiveBlending : NormalBlending;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tquad.material.map = pathTracer.target.texture;\r\n\t\t\t\tthis.renderToCanvasCallback( pathTracer.target, renderer, quad );\r\n\t\t\t\tquad.material.blending = NoBlending;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._queueReset = true;\r\n\t\tthis._pathTracer.samples = 0;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tif ( this._rasterEnvMap ) {\r\n\r\n\t\t\tthis._rasterEnvMap.dispose();\r\n\t\t\tthis._rasterEnvMap = null;\r\n\t\t\tthis._previousRasterEnvMapSource = null;\r\n\r\n\t\t}\r\n\t\tthis._quad.dispose();\r\n\t\tthis._quad.material.dispose();\r\n\t\tthis._pathTracer.dispose();\r\n\r\n\t}\r\n\r\n\t_updateScale() {\r\n\r\n\t\t// update the path tracer scale if it has changed\r\n\t\tif ( this.synchronizeRenderSize ) {\r\n\r\n\t\t\tthis._renderer.getDrawingBufferSize( _resolution );\r\n\r\n\t\t\tconst w = Math.floor( this.renderScale * _resolution.x );\r\n\t\t\tconst h = Math.floor( this.renderScale * _resolution.y );\r\n\r\n\t\t\tthis._pathTracer.getSize( _resolution );\r\n\t\t\tif ( _resolution.x !== w || _resolution.y !== h ) {\r\n\r\n\t\t\t\tconst lowResScale = this.lowResScale;\r\n\t\t\t\tthis._pathTracer.setSize( w, h );\r\n\t\t\t\tthis._lowResPathTracer.setSize( Math.floor( w * lowResScale ), Math.floor( h * lowResScale ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"],"names":["_uv","Vector2","_coord","_polar","Spherical","_color","Color","ProceduralEquirectTexture","DataTexture","width","height","RGBAFormat","FloatType","EquirectangularReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","LinearFilter","data","x","y","i4","other","_direction","Vector3","GradientEquirectTexture","resolution","polar","uv","coord","color","t","ClampedInterpolationMaterial","ShaderMaterial","v","_b","_a","params","CubeToEquirectMaterial","CommonGLSL.util_functions","CubeToEquirectGenerator","renderer","FullScreenQuad","source","image","quad","target","WebGLRenderTarget","imageHeight","maxMip","texelHeight","texelWidth","currentTarget","currentAutoClear","buffer","readBuffer","i","l","DataUtils","result","HalfFloatType","LinearMipMapLinearFilter","supportsFloatBlending","_resolution","WebGLPathTracer","PathTracingSceneGenerator","PathTracingRenderer","Clock","NoBlending","scene","camera","Scene","PerspectiveCamera","worker","options","generator","args","material","materials","textureSize","textures","getTextures","m","lights","getLights","iesTextures","getIesTextures","colorBackground","background","environment","sanitizedMap","self","sc","stride","floatData","results","geometry","bvh","bvhChanged","needsMaterialIndexUpdate","resolve","lowResPathTracer","pathTracer","clock","delta","elapsedTime","minSamples","currentOpacity","AdditiveBlending","NormalBlending","w","h","lowResScale"],"mappings":"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"}