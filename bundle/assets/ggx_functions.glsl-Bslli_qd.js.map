{"version":3,"file":"ggx_functions.glsl-Bslli_qd.js","sources":["../../src/shader/common/math_functions.glsl.js","../../src/shader/common/util_functions.glsl.js","../../src/shader/bsdf/ggx_functions.glsl.js"],"sourcesContent":["export const math_functions = /* glsl */`\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\r\n","export const util_functions = /* glsl */`\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\r\n","export const ggx_functions = /* glsl */`\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / max( abs( wi.z ), 1e-7 );\r\n\r\n\t}\r\n\r\n`;\r\n"],"names":["math_functions","util_functions","ggx_functions"],"mappings":"AAAY,MAACA,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA3BC,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA3BC,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}