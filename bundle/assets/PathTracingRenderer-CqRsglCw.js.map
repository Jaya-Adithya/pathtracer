{"version":3,"file":"PathTracingRenderer-CqRsglCw.js","sources":["../../src/shader/structs/camera_struct.glsl.js","../../src/shader/structs/equirect_struct.glsl.js","../../src/shader/structs/lights_struct.glsl.js","../../src/shader/structs/surface_record_struct.glsl.js","../../src/shader/sampling/equirect_sampling_functions.glsl.js","../../src/shader/sampling/light_sampling_functions.glsl.js","../../src/shader/rand/sobol.glsl.js","../../src/shader/rand/stratified.glsl.js","../../src/materials/fullscreen/BlendMaterial.js","../../src/utils/SobolNumberMapGenerator.js","../../src/objects/PhysicalCamera.js","../../src/uniforms/PhysicalCameraUniform.js","../../src/utils/TextureUtils.js","../../src/uniforms/EquirectHdrInfoUniform.js","../../src/uniforms/LightsInfoUniformStruct.js","../../src/uniforms/FloatAttributeTextureArray.js","../../src/uniforms/AttributesTextureArray.js","../../src/uniforms/RenderTarget2DArray.js","../../src/uniforms/stratified/StratifiedSampler.js","../../src/uniforms/stratified/StratifiedSamplerCombined.js","../../src/uniforms/StratifiedSamplesTexture.js","../../src/textures/blueNoise/utils.js","../../src/textures/blueNoise/BlueNoiseSamples.js","../../src/textures/blueNoise/BlueNoiseGenerator.js","../../src/textures/BlueNoiseTexture.js","../../src/shader/common/fresnel_functions.glsl.js","../../src/shader/common/shape_intersection_functions.glsl.js","../../src/shader/common/texture_sample_functions.glsl.js","../../src/shader/bsdf/bsdf_functions.glsl.js","../../src/shader/bsdf/fog_functions.glsl.js","../../src/shader/bsdf/iridescence_functions.glsl.js","../../src/shader/bsdf/sheen_functions.glsl.js","../../src/shader/bvh/inside_fog_volume_function.glsl.js","../../src/materials/pathtracing/glsl/attenuate_hit_function.glsl.js","../../src/materials/pathtracing/glsl/camera_util_functions.glsl.js","../../src/materials/pathtracing/glsl/direct_light_contribution_function.glsl.js","../../src/materials/pathtracing/glsl/get_surface_record_function.glsl.js","../../src/materials/pathtracing/glsl/render_structs.glsl.js","../../src/materials/pathtracing/glsl/trace_scene_function.glsl.js","../../src/materials/pathtracing/PhysicalPathTracingMaterial.js","../../src/core/PathTracingRenderer.js"],"sourcesContent":["export const camera_struct = /* glsl */`\r\n\r\n\tstruct PhysicalCamera {\r\n\r\n\t\tfloat focusDistance;\r\n\t\tfloat anamorphicRatio;\r\n\t\tfloat bokehSize;\r\n\t\tint apertureBlades;\r\n\t\tfloat apertureRotation;\r\n\r\n\t};\r\n\r\n`;\r\n","export const equirect_struct = /* glsl */`\r\n\r\n\tstruct EquirectHdrInfo {\r\n\r\n\t\tsampler2D marginalWeights;\r\n\t\tsampler2D conditionalWeights;\r\n\t\tsampler2D map;\r\n\r\n\t\tfloat totalSum;\r\n\r\n\t};\r\n\r\n`;\r\n","export const lights_struct = /* glsl */`\r\n\r\n\t#define RECT_AREA_LIGHT_TYPE 0\r\n\t#define CIRC_AREA_LIGHT_TYPE 1\r\n\t#define SPOT_LIGHT_TYPE 2\r\n\t#define DIR_LIGHT_TYPE 3\r\n\t#define POINT_LIGHT_TYPE 4\r\n\r\n\tstruct LightsInfo {\r\n\r\n\t\tsampler2D tex;\r\n\t\tuint count;\r\n\r\n\t};\r\n\r\n\tstruct Light {\r\n\r\n\t\tvec3 position;\r\n\t\tint type;\r\n\r\n\t\tvec3 color;\r\n\t\tfloat intensity;\r\n\r\n\t\tvec3 u;\r\n\t\tvec3 v;\r\n\t\tfloat area;\r\n\r\n\t\t// spot light fields\r\n\t\tfloat radius;\r\n\t\tfloat near;\r\n\t\tfloat decay;\r\n\t\tfloat distance;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\tint iesProfile;\r\n\r\n\t};\r\n\r\n\tLight readLightInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 6u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\r\n\t\tLight l;\r\n\t\tl.position = s0.rgb;\r\n\t\tl.type = int( round( s0.a ) );\r\n\r\n\t\tl.color = s1.rgb;\r\n\t\tl.intensity = s1.a;\r\n\r\n\t\tl.u = s2.rgb;\r\n\t\tl.v = s3.rgb;\r\n\t\tl.area = s3.a;\r\n\r\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\t\tl.radius = s4.r;\r\n\t\t\tl.decay = s4.g;\r\n\t\t\tl.distance = s4.b;\r\n\t\t\tl.coneCos = s4.a;\r\n\r\n\t\t\tl.penumbraCos = s5.r;\r\n\t\t\tl.iesProfile = int( round( s5.g ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl.radius = 0.0;\r\n\t\t\tl.decay = 0.0;\r\n\t\t\tl.distance = 0.0;\r\n\r\n\t\t\tl.coneCos = 0.0;\r\n\t\t\tl.penumbraCos = 0.0;\r\n\t\t\tl.iesProfile = - 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn l;\r\n\r\n\t}\r\n\r\n`;\r\n","export const surface_record_struct = /* glsl */`\r\n\r\n\tstruct SurfaceRecord {\r\n\r\n\t\t// surface type\r\n\t\tbool volumeParticle;\r\n\r\n\t\t// geometry\r\n\t\tvec3 faceNormal;\r\n\t\tbool frontFace;\r\n\t\tvec3 normal;\r\n\t\tmat3 normalBasis;\r\n\t\tmat3 normalInvBasis;\r\n\r\n\t\t// cached properties\r\n\t\tfloat eta;\r\n\t\tfloat f0;\r\n\r\n\t\t// material\r\n\t\tfloat roughness;\r\n\t\tfloat filteredRoughness;\r\n\t\tfloat metalness;\r\n\t\tvec3 color;\r\n\t\tvec3 emission;\r\n\r\n\t\t// transmission\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tbool thinFilm;\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\t// clearcoat\r\n\t\tvec3 clearcoatNormal;\r\n\t\tmat3 clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis;\r\n\t\tfloat clearcoat;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tfloat filteredClearcoatRoughness;\r\n\r\n\t\t// sheen\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tfloat sheenRoughness;\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThickness;\r\n\r\n\t\t// specular\r\n\t\tvec3 specularColor;\r\n\t\tfloat specularIntensity;\r\n\t};\r\n\r\n\tstruct ScatterRecord {\r\n\t\tfloat specularPdf;\r\n\t\tfloat pdf;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t};\r\n\r\n`;\r\n","export const equirect_functions = /* glsl */`\r\n\r\n\t// samples the the given environment map in the given direction\r\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\r\n\r\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\r\n\r\n\t}\r\n\r\n\t// gets the pdf of the given direction to sample\r\n\tfloat equirectDirectionPdf( vec3 direction ) {\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tfloat theta = uv.y * PI;\r\n\t\tfloat sinTheta = sin( theta );\r\n\t\tif ( sinTheta == 0.0 ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\r\n\r\n\t}\r\n\r\n\t// samples the color given env map with CDF and returns the pdf of the direction\r\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tif ( totalSum == 0.0 ) {\r\n\r\n\t\t\tcolor = vec3( 0.0 );\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n\r\n\t// samples a direction of the envmap with color and retrieves pdf\r\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\r\n\r\n\t\t// sample env map cdf\r\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\r\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\r\n\t\tvec2 uv = vec2( u, v );\r\n\r\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\r\n\t\tdirection = derivedDirection;\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n`;\r\n","export const light_sampling_functions = /* glsl */`\r\n\r\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\r\n\r\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\r\n\r\n\t}\r\n\r\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t\t// page 32, equation 26: E[window1]\r\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\r\n\r\n\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn distanceFalloff;\r\n\r\n\t}\r\n\r\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\r\n\r\n\t\tfloat cosTheta = dot( posToLight, lightDir );\r\n\t\tfloat angle = acos( cosTheta ) / PI;\r\n\r\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\r\n\r\n\t}\r\n\r\n\tstruct LightRecord {\r\n\r\n\t\tfloat dist;\r\n\t\tvec3 direction;\r\n\t\tfloat pdf;\r\n\t\tvec3 emission;\r\n\t\tint type;\r\n\r\n\t};\r\n\r\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\r\n\r\n\t\tbool didHit = false;\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\r\n\t\t// check for backface\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\r\n\r\n\t\t\tu *= 1.0 / dot( u, u );\r\n\t\t\tv *= 1.0 / dot( v, v );\r\n\r\n\t\t\tfloat dist;\r\n\r\n\t\t\t// MIS / light intersection is not supported for punctual lights.\r\n\t\t\tif(\r\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\r\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\r\n\t\t\t\tdidHit = true;\r\n\t\t\t\tlightRec.dist = dist;\r\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\r\n\t\t\t\tlightRec.emission = light.color * light.intensity;\r\n\t\t\t\tlightRec.direction = rayDirection;\r\n\t\t\t\tlightRec.type = light.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn didHit;\r\n\r\n\t}\r\n\r\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tvec3 randomPos;\r\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// rectangular area light\r\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\r\n\r\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// circular area light\r\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\r\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\t\tfloat x = r * cos( theta );\r\n\t\t\tfloat y = r * sin( theta );\r\n\r\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\t\tvec3 direction = toLight / dist;\r\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\r\n\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.emission = light.color * light.intensity;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\r\n\t\tlightRec.pdf = lightDistSq / max( light.area * abs( dot( direction, lightNormal ) ), 1e-6 );\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tfloat radius = light.radius * sqrt( ruv.x );\r\n\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\tfloat x = radius * cos( theta );\r\n\t\tfloat y = radius * sin( theta );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\r\n\t\tfloat angle = acos( light.coneCos );\r\n\t\tfloat angleTan = tan( angle );\r\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\r\n\r\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\r\n\t\tvec3 direction = toLight / max( dist, EPSILON );\r\n\t\tfloat cosTheta = dot( direction, normal );\r\n\r\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\r\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\r\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\r\n\r\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\r\n\t\tlightRec.pdf = 1.0;\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\r\n\r\n\t\tLightRecord result;\r\n\r\n\t\t// pick a random light\r\n\t\tuint l = uint( ruv.x * float( lightCount ) );\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\r\n\r\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\r\n\r\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec3 lightRay = light.u - rayOrigin;\r\n\t\t\tfloat lightDist = length( lightRay );\r\n\t\t\tfloat cutoffDistance = light.distance;\r\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\r\n\t\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.direction = normalize( lightRay );\r\n\t\t\trec.dist = length( lightRay );\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\r\n\t\t\trec.type = light.type;\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.dist = 1e10;\r\n\t\t\trec.direction = light.u;\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity;\r\n\t\t\trec.type = light.type;\r\n\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// sample the light\r\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","// References\r\n// - https://jcgt.org/published/0009/04/01/\r\n// - Code from https://www.shadertoy.com/view/WtGyDm\r\n\r\n// functions to generate multi-dimensions variables of the same functions\r\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\r\nfunction generateSobolFunctionVariants( dim = 1 ) {\r\n\r\n\tlet type = 'uint';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\ttype = 'uvec' + dim;\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\t\t${ type } sobolReverseBits( ${ type } x ) {\r\n\r\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\r\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\r\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\r\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\r\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\r\n\r\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx += seed;\r\n\t\t\tx ^= x * 0x6c50b47cu;\r\n\t\t\tx ^= x * 0xb82f1e52u;\r\n\t\t\tx ^= x * 0xc7afe638u;\r\n\t\t\tx ^= x * 0x8d22f6e6u;\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\r\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\r\n\t\t\tx = sobolReverseBits( x );\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nfunction generateSobolSampleFunctions( dim = 1 ) {\r\n\r\n\tlet utype = 'uint';\r\n\tlet vtype = 'float';\r\n\tlet num = '';\r\n\tlet components = '.r';\r\n\tlet combineValues = '1u';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\tutype = 'uvec' + dim;\r\n\t\tvtype = 'vec' + dim;\r\n\t\tnum = dim + '';\r\n\t\tif ( dim === 2 ) {\r\n\r\n\t\t\tcomponents = '.rg';\r\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\r\n\r\n\t\t} else if ( dim === 3 ) {\r\n\r\n\t\t\tcomponents = '.rgb';\r\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcomponents = '';\r\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\r\n\t\t${ vtype } sobol${ num }( int effect ) {\r\n\r\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\r\n\t\t\tuint index = sobolPathIndex;\r\n\r\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\r\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\r\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\r\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\r\n\r\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\r\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\r\n\r\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nexport const sobol_common = /* glsl */`\r\n\r\n\t// Utils\r\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\r\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\r\n\r\n\t${ generateSobolFunctionVariants( 1 ) }\r\n\t${ generateSobolFunctionVariants( 2 ) }\r\n\t${ generateSobolFunctionVariants( 3 ) }\r\n\t${ generateSobolFunctionVariants( 4 ) }\r\n\r\n\tuint sobolHash( uint x ) {\r\n\r\n\t\t// finalizer from murmurhash3\r\n\t\tx ^= x >> 16;\r\n\t\tx *= 0x85ebca6bu;\r\n\t\tx ^= x >> 13;\r\n\t\tx *= 0xc2b2ae35u;\r\n\t\tx ^= x >> 16;\r\n\t\treturn x;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_point_generation = /* glsl */`\r\n\r\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\r\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\r\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\r\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\r\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\r\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\r\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\r\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\r\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\r\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\r\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\r\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\r\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\r\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\r\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\r\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\r\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\r\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\r\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\r\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\r\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\r\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\r\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\r\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\r\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\r\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\r\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\r\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\r\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\r\n\t);\r\n\r\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\r\n\r\n\t\tuint X = 0u;\r\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\r\n\r\n\t\t\tuint mask = ( index >> bit ) & 1u;\r\n\t\t\tX ^= mask * directions[ bit ];\r\n\r\n\t\t}\r\n\t\treturn X;\r\n\r\n\t}\r\n\r\n\tvec4 generateSobolPoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\treturn vec4( 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\t// NOTE: this sobol \"direction\" is also available but we can't write out 5 components\r\n\t\t// uint x = index & 0x00ffffffu;\r\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\r\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\r\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\r\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\r\n\r\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_functions = /* glsl */`\r\n\r\n\t// Seeds\r\n\tuniform sampler2D sobolTexture;\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\r\n\tuint sobolGetSeed( uint bounce, uint effect ) {\r\n\r\n\t\treturn sobolHash(\r\n\t\t\tsobolHashCombine(\r\n\t\t\t\tsobolHashCombine(\r\n\t\t\t\t\tsobolHash( bounce ),\r\n\t\t\t\t\tsobolPixelIndex\r\n\t\t\t\t),\r\n\t\t\t\teffect\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tvec4 sobolGetTexturePoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\tindex = index % SOBOL_MAX_POINTS;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\r\n\t\tuint y = index / dim.x;\r\n\t\tuint x = index - y * dim.x;\r\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\r\n\t\treturn texture( sobolTexture, uv );\r\n\r\n\t}\r\n\r\n\t${ generateSobolSampleFunctions( 1 ) }\r\n\t${ generateSobolSampleFunctions( 2 ) }\r\n\t${ generateSobolSampleFunctions( 3 ) }\r\n\t${ generateSobolSampleFunctions( 4 ) }\r\n\r\n`;\r\n","export const stratified_functions = /* glsl */`\r\n\r\n\tuniform sampler2D stratifiedTexture;\r\n\tuniform sampler2D stratifiedOffsetTexture;\r\n\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\tvec4 pixelSeed = vec4( 0 );\r\n\r\n\tvec4 rand4( int v ) {\r\n\r\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\r\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\r\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\r\n\r\n\t}\r\n\r\n\tvec3 rand3( int v ) {\r\n\r\n\t\treturn rand4( v ).xyz;\r\n\r\n\t}\r\n\r\n\tvec2 rand2( int v ) {\r\n\r\n\t\treturn rand4( v ).xy;\r\n\r\n\t}\r\n\r\n\tfloat rand( int v ) {\r\n\r\n\t\treturn rand4( v ).x;\r\n\r\n\t}\r\n\r\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\r\n\r\n\t\t// tile the small noise texture across the entire screen\r\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\r\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\r\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\r\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\r\n\r\n\t\t// note that using \"texelFetch\" here seems to break Android for some reason\r\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\r\n\r\n\t}\r\n\r\n`;\r\n","import { NoBlending } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\n\r\nexport class BlendMaterial extends MaterialBase {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\ttarget1: { value: null },\r\n\t\t\t\ttarget2: { value: null },\r\n\t\t\t\topacity: { value: 1.0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tuniform sampler2D target1;\r\n\t\t\t\tuniform sampler2D target2;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\r\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\r\n\r\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\r\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\r\n\r\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\r\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { MaterialBase } from '../materials/MaterialBase.js';\r\nimport { sobol_common, sobol_point_generation } from '../shader/rand/sobol.glsl.js';\r\n\r\nclass SobolNumbersMaterial extends MaterialBase {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t${ sobol_common }\r\n\t\t\t\t${ sobol_point_generation }\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\r\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class SobolNumberMapGenerator {\r\n\r\n\tgenerate( renderer, dimensions = 256 ) {\r\n\r\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\r\n\r\n\t\t\ttype: FloatType,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tgenerateMipmaps: false,\r\n\r\n\t\t} );\r\n\r\n\t\tconst ogTarget = renderer.getRenderTarget();\r\n\t\trenderer.setRenderTarget( target );\r\n\r\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\r\n\t\tquad.material.resolution.set( dimensions, dimensions );\r\n\t\tquad.render( renderer );\r\n\r\n\t\trenderer.setRenderTarget( ogTarget );\r\n\t\tquad.dispose();\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n","import { PerspectiveCamera } from 'three';\r\n\r\nexport class PhysicalCamera extends PerspectiveCamera {\r\n\r\n\tset bokehSize( size ) {\r\n\r\n\t\tthis.fStop = this.getFocalLength() / size;\r\n\r\n\t}\r\n\r\n\tget bokehSize() {\r\n\r\n\t\treturn this.getFocalLength() / this.fStop;\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.fStop = 1.4;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 25;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.fStop = source.fStop;\r\n\t\tthis.apertureBlades = source.apertureBlades;\r\n\t\tthis.apertureRotation = source.apertureRotation;\r\n\t\tthis.focusDistance = source.focusDistance;\r\n\t\tthis.anamorphicRatio = source.anamorphicRatio;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { PhysicalCamera } from '../objects/PhysicalCamera.js';\r\nexport class PhysicalCameraUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.bokehSize = 0;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 10;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tupdateFrom( camera ) {\r\n\r\n\t\tif ( camera instanceof PhysicalCamera ) {\r\n\r\n\t\t\tthis.bokehSize = camera.bokehSize;\r\n\t\t\tthis.apertureBlades = camera.apertureBlades;\r\n\t\t\tthis.apertureRotation = camera.apertureRotation;\r\n\t\t\tthis.focusDistance = camera.focusDistance;\r\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.bokehSize = 0;\r\n\t\t\tthis.apertureRotation = 0;\r\n\t\t\tthis.apertureBlades = 0;\r\n\t\t\tthis.focusDistance = 10;\r\n\t\t\tthis.anamorphicRatio = 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { DataUtils } from 'three';\r\n\r\n\r\nexport function toHalfFloatArray( f32Array ) {\r\n\r\n\tconst f16Array = new Uint16Array( f32Array.length );\r\n\tfor ( let i = 0, n = f32Array.length; i < n; ++ i ) {\r\n\r\n\t\tf16Array[ i ] = DataUtils.toHalfFloat( f32Array[ i ] );\r\n\r\n\t}\r\n\r\n\treturn f16Array;\r\n\r\n}\r\n","import { DataTexture, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping, RGBAFormat, FloatType, ClampToEdgeWrapping } from 'three';\r\nimport { toHalfFloatArray } from '../utils/TextureUtils.js';\r\n\r\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\r\n\r\n\tlet lower = offset;\r\n\tlet upper = offset + count - 1;\r\n\r\n\twhile ( lower < upper ) {\r\n\r\n\t\tconst mid = ( lower + upper ) >> 1;\r\n\r\n\t\tif ( array[ mid ] < targetValue ) {\r\n\t\t\tlower = mid + 1;\r\n\t\t} else {\r\n\t\t\tupper = mid;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn lower - offset;\r\n\r\n}\r\n\r\nfunction colorToLuminance( r, g, b ) {\r\n\t// https://en.wikipedia.org/wiki/Relative_luminance\r\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\r\n}\r\n\r\n// ensures the data is all floating point values and flipY is false\r\nfunction preprocessEnvMap( envMap, targetType = HalfFloatType ) {\r\n\r\n\tconst map = envMap.clone();\r\n\tmap.source = new Source( { ...map.image } );\r\n\tconst { width, height, data } = map.image;\r\n\r\n\t// [FIX 1] Calculate stride dynamically (3 for RGB, 4 for RGBA) to prevent data corruption\r\n\tconst originalStride = Math.floor( data.length / ( width * height ) );\r\n\r\n\t// Force copy and sanitization\r\n\tlet newData;\r\n\tconst targetStride = originalStride;\r\n\r\n\tif ( targetType === HalfFloatType ) {\r\n\t\tnewData = new Uint16Array( data.length );\r\n\t} else {\r\n\t\tnewData = new Float32Array( data.length );\r\n\t}\r\n\r\n\tlet maxIntValue;\r\n\tif ( data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array || data instanceof Uint8Array || data instanceof Uint16Array || data instanceof Uint32Array ) {\r\n\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT ) - 1;\r\n\t} else {\r\n\t\tmaxIntValue = 1;\r\n\t}\r\n\r\n\t// [FIX 2] HalfFloat Max Value. Clamp sun to this instead of 0.\r\n\tconst MAX_HALF_FLOAT = 65504.0;\r\n\r\n\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\r\n\r\n\t\tlet v = data[ i ];\r\n\t\tif ( map.type === HalfFloatType ) {\r\n\t\t\tv = DataUtils.fromHalfFloat( data[ i ] );\r\n\t\t}\r\n\r\n\t\tif ( map.type !== FloatType && map.type !== HalfFloatType ) {\r\n\t\t\tv /= maxIntValue;\r\n\t\t}\r\n\r\n\t\t// [FIX 2] Robust Sanitization: If Infinity (Sun), clamp to max value. Do not set to 0.\r\n\t\tif ( ! Number.isFinite( v ) ) {\r\n\t\t\tif ( v > 0 ) v = MAX_HALF_FLOAT;\r\n\t\t\telse v = 0.0;\r\n\t\t} else if ( v < 0 ) {\r\n\t\t\tv = 0.0;\r\n\t\t}\r\n\r\n\t\tif ( targetType === HalfFloatType ) {\r\n\t\t\tnewData[ i ] = DataUtils.toHalfFloat( v );\r\n\t\t} else {\r\n\t\t\tnewData[ i ] = v;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tmap.image.data = newData;\r\n\tmap.type = targetType;\r\n\r\n\t// remove any y flipping for cdf computation\r\n\tif ( map.flipY ) {\r\n\r\n\t\tconst ogData = newData;\r\n\t\tnewData = newData.slice();\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst newY = height - y - 1;\r\n\t\t\t\t// [FIX 3] Use calculated stride for flipping logic\r\n\t\t\t\tconst ogIndex = targetStride * ( y * width + x );\r\n\t\t\t\tconst newIndex = targetStride * ( newY * width + x );\r\n\r\n\t\t\t\tfor ( let c = 0; c < targetStride; c ++ ) {\r\n\t\t\t\t\tnewData[ newIndex + c ] = ogData[ ogIndex + c ];\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.flipY = false;\r\n\t\tmap.image.data = newData;\r\n\r\n\t}\r\n\r\n\treturn map;\r\n\r\n}\r\n\r\nexport class EquirectHdrInfoUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst blackTex = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 0, 0 ] ) ), 1, 1 );\r\n\t\tblackTex.type = HalfFloatType;\r\n\t\tblackTex.format = RGBAFormat;\r\n\t\tblackTex.minFilter = LinearFilter;\r\n\t\tblackTex.magFilter = LinearFilter;\r\n\t\tblackTex.wrapS = RepeatWrapping;\r\n\t\tblackTex.wrapT = RepeatWrapping;\r\n\t\tblackTex.generateMipmaps = false;\r\n\t\tblackTex.needsUpdate = true;\r\n\r\n\t\tconst marginalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 1 ] ) ), 1, 2 );\r\n\t\tmarginalWeights.type = HalfFloatType;\r\n\t\tmarginalWeights.format = RedFormat;\r\n\t\tmarginalWeights.minFilter = LinearFilter;\r\n\t\tmarginalWeights.magFilter = LinearFilter;\r\n\t\tmarginalWeights.generateMipmaps = false;\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\tconst conditionalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 1, 1 ] ) ), 2, 2 );\r\n\t\tconditionalWeights.type = HalfFloatType;\r\n\t\tconditionalWeights.format = RedFormat;\r\n\t\tconditionalWeights.minFilter = LinearFilter;\r\n\t\tconditionalWeights.magFilter = LinearFilter;\r\n\t\tconditionalWeights.generateMipmaps = false;\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.map = blackTex;\r\n\t\tthis.marginalWeights = marginalWeights;\r\n\t\tthis.conditionalWeights = conditionalWeights;\r\n\t\tthis.totalSum = 0;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.marginalWeights.dispose();\r\n\t\tthis.conditionalWeights.dispose();\r\n\t\tthis.map.dispose();\r\n\r\n\t}\r\n\r\n\tupdateFrom( hdr ) {\r\n\r\n\t\tconst map = preprocessEnvMap( hdr );\r\n\t\tmap.wrapS = RepeatWrapping;\r\n\t\tmap.wrapT = ClampToEdgeWrapping;\r\n\r\n\t\tconst { width, height, data } = map.image;\r\n\r\n\t\tif ( ! width || ! height || ! data ) {\r\n\t\t\tconsole.error( 'EquirectHdrInfoUniform: Invalid texture data', map.image );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// [FIX 1] Calculate Stride dynamically here as well\r\n\t\tconst stride = Math.floor( data.length / ( width * height ) );\r\n\r\n\t\tconst pdfConditional = new Float32Array( width * height );\r\n\t\tconst cdfConditional = new Float32Array( width * height );\r\n\r\n\t\tconst pdfMarginal = new Float32Array( height );\r\n\t\tconst cdfMarginal = new Float32Array( height );\r\n\r\n\t\tlet totalSumValue = 0.0;\r\n\t\tlet cumulativeWeightMarginal = 0.0;\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tlet cumulativeRowWeight = 0.0;\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\r\n\t\t\t\t// [FIX 1] Use stride here instead of hardcoded 4\r\n\t\t\t\tlet r = DataUtils.fromHalfFloat( data[ stride * i + 0 ] );\r\n\t\t\t\tlet g = DataUtils.fromHalfFloat( data[ stride * i + 1 ] );\r\n\t\t\t\tlet b = DataUtils.fromHalfFloat( data[ stride * i + 2 ] );\r\n\r\n\t\t\t\t// Redundant safety check (already handled in preprocess, but good for safety)\r\n\t\t\t\tif ( ! Number.isFinite( r ) || r < 0 ) { r = 0; }\r\n\t\t\t\tif ( ! Number.isFinite( g ) || g < 0 ) { g = 0; }\r\n\t\t\t\tif ( ! Number.isFinite( b ) || b < 0 ) { b = 0; }\r\n\r\n\t\t\t\tlet weight = colorToLuminance( r, g, b );\r\n\t\t\t\tif ( ! Number.isFinite( weight ) || weight < 0 ) weight = 0;\r\n\t\t\t\tcumulativeRowWeight += weight;\r\n\t\t\t\ttotalSumValue += weight;\r\n\r\n\t\t\t\tpdfConditional[ i ] = weight;\r\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\r\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\r\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\r\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\r\n\r\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\r\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\r\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\r\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst marginalDataArray = new Uint16Array( height );\r\n\t\tconst conditionalDataArray = new Uint16Array( width * height );\r\n\r\n\t\tfor ( let i = 0; i < height; i ++ ) {\r\n\t\t\tconst dist = ( i + 1 ) / height;\r\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\r\n\t\t\tmarginalDataArray[ i ] = DataUtils.toHalfFloat( ( row + 0.5 ) / height );\r\n\t\t}\r\n\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst dist = ( x + 1 ) / width;\r\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\r\n\t\t\t\tconditionalDataArray[ i ] = DataUtils.toHalfFloat( ( col + 0.5 ) / width );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.dispose();\r\n\r\n\t\tconst { marginalWeights, conditionalWeights } = this;\r\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.totalSum = Number.isFinite( totalSumValue ) ? totalSumValue : 0;\r\n\r\n\t\tif ( this.totalSum === 0 ) {\r\n\t\t\tconsole.warn( 'EquirectHdrInfoUniform: totalSum is 0. The environment map appears to be black or empty.', { width, height } );\r\n\t\t}\r\n\r\n\t\tthis.map = map;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4, NearestFilter } from 'three';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nconst LIGHT_PIXELS = 6;\r\nconst RECT_AREA_LIGHT = 0;\r\nconst CIRC_AREA_LIGHT = 1;\r\nconst SPOT_LIGHT = 2;\r\nconst DIR_LIGHT = 3;\r\nconst POINT_LIGHT = 4;\r\n\r\nconst u = new Vector3();\r\nconst v = new Vector3();\r\nconst m = new Matrix4();\r\nconst worldQuaternion = new Quaternion();\r\nconst eye = new Vector3();\r\nconst target = new Vector3();\r\nconst up = new Vector3( 0, 1, 0 );\r\nexport class LightsInfoUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\r\n\t\ttex.format = RGBAFormat;\r\n\t\ttex.type = FloatType;\r\n\t\ttex.wrapS = ClampToEdgeWrapping;\r\n\t\ttex.wrapT = ClampToEdgeWrapping;\r\n\t\ttex.generateMipmaps = false;\r\n\t\ttex.minFilter = NearestFilter;\r\n\t\ttex.magFilter = NearestFilter;\r\n\r\n\t\tthis.tex = tex;\r\n\t\tthis.count = 0;\r\n\r\n\t}\r\n\r\n\tupdateFrom( lights, iesTextures = [] ) {\r\n\r\n\t\tconst tex = this.tex;\r\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\r\n\r\n\t\tif ( tex.image.width !== dimension ) {\r\n\r\n\t\t\ttex.dispose();\r\n\r\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\ttex.image.width = dimension;\r\n\t\t\ttex.image.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = tex.image.data;\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst l = lights[ i ];\r\n\r\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\t// initialize to 0\r\n\t\t\tfor ( let p = 0; p < LIGHT_PIXELS * 4; p ++ ) {\r\n\r\n\t\t\t\tfloatArray[ baseIndex + p ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 1\r\n\t\t    // position\r\n\t\t\tl.getWorldPosition( v );\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t// type\r\n\t\t\tlet type = RECT_AREA_LIGHT;\r\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\r\n\r\n\t\t\t\ttype = CIRC_AREA_LIGHT;\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\ttype = SPOT_LIGHT;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\ttype = DIR_LIGHT;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\ttype = POINT_LIGHT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// color\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\r\n\r\n\t\t\t// intensity\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\r\n\r\n\t\t\tl.getWorldQuaternion( worldQuaternion );\r\n\r\n\t\t\tif ( l.isRectAreaLight ) {\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\tconst radius = l.radius || 0;\r\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\tm.lookAt( eye, target, up );\r\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\t// radius\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\r\n\r\n\t\t\t\t// decay\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\r\n\t\t\t\t// distance\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t\t// coneCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\r\n\r\n\t\t\t\t// sample 6\r\n\t\t\t\t// penumbraCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\r\n\r\n\t\t\t\t// iesProfile\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.iesMap ? iesTextures.indexOf( l.iesMap ) : - 1;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\tindex += 4;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\tindex += 1;\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\tconst targetPosition = v.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = lights.length;\r\n\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\ttex.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\r\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\r\n\r\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\r\n\r\n\tif ( fromStride > toStride ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// scale non-float values to their normalized range\r\n\tconst count = fromArray.length / fromStride;\r\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\r\n\tlet maxValue = 1.0;\r\n\tswitch ( fromArray.constructor ) {\r\n\r\n\tcase Uint8Array:\r\n\tcase Uint16Array:\r\n\tcase Uint32Array:\r\n\t\tmaxValue = 2 ** bpe - 1;\r\n\t\tbreak;\r\n\r\n\tcase Int8Array:\r\n\tcase Int16Array:\r\n\tcase Int32Array:\r\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\r\n\t\tbreak;\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tconst i4 = 4 * i;\r\n\t\tconst is = fromStride * i;\r\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\r\n\r\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class FloatAttributeTextureArray extends DataArrayTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._textures = [];\r\n\t\tthis.type = FloatType;\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.internalFormat = 'RGBA32F';\r\n\r\n\t}\r\n\r\n\tupdateAttribute( index, attr ) {\r\n\r\n\t\t// update the texture\r\n\t\tconst tex = this._textures[ index ];\r\n\t\ttex.updateFrom( attr );\r\n\r\n\t\t// ensure compatibility\r\n\t\tconst baseImage = tex.image;\r\n\t\tconst image = this.image;\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\r\n\r\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\r\n\r\n\t\t}\r\n\r\n\t\t// update the image\r\n\t\tconst { width, height, data } = image;\r\n\t\tconst length = width * height * 4;\r\n\t\tconst offset = length * index;\r\n\t\tlet itemSize = attr.itemSize;\r\n\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\titemSize = 4;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data\r\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tsetAttributes( attrs ) {\r\n\r\n\t\t// ensure the attribute count\r\n\t\tconst itemCount = attrs[ 0 ].count;\r\n\t\tconst attrsLength = attrs.length;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\r\n\r\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// initialize all textures\r\n\t\tconst textures = this._textures;\r\n\t\twhile ( textures.length < attrsLength ) {\r\n\r\n\t\t\tconst tex = new FloatVertexAttributeTexture();\r\n\t\t\ttextures.push( tex );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( textures.length > attrsLength ) {\r\n\r\n\t\t\ttextures.pop();\r\n\r\n\t\t}\r\n\r\n\t\t// update all textures\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// determine if we need to create a new array\r\n\t\tconst baseTexture = textures[ 0 ];\r\n\t\tconst baseImage = baseTexture.image;\r\n\t\tconst image = this.image;\r\n\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\r\n\r\n\t\t\timage.width = baseImage.width;\r\n\t\t\timage.height = baseImage.height;\r\n\t\t\timage.depth = attrsLength;\r\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\r\n\r\n\t\t}\r\n\r\n\t\t// copy the other texture data into the data array texture\r\n\t\tconst { data, width, height } = image;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tconst tex = textures[ i ];\r\n\t\t\tconst length = width * height * 4;\r\n\t\t\tconst offset = length * i;\r\n\r\n\t\t\tlet itemSize = attrs[ i ].itemSize;\r\n\t\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\t\titemSize = 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\t}\r\n\r\n\t\t// reset the texture\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\r\n}\r\n","import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\r\n\r\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\r\n\r\n\tupdateNormalAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 0, attr );\r\n\r\n\t}\r\n\r\n\tupdateTangentAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 1, attr );\r\n\r\n\t}\r\n\r\n\tupdateUvAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 2, attr );\r\n\r\n\t}\r\n\r\n\tupdateColorAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 3, attr );\r\n\r\n\t}\r\n\r\n\tupdateFrom( normal, tangent, uv, color ) {\r\n\r\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tWebGLArrayRenderTarget,\r\n\tRGBAFormat,\r\n\tHalfFloatType,\r\n\tColor,\r\n\tRepeatWrapping,\r\n\tLinearFilter,\r\n\tNoToneMapping,\r\n\tShaderMaterial,\r\n} from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\n\r\nconst prevColor = new Color();\r\nfunction getTextureHash( texture ) {\r\n\r\n\treturn texture ? `${ texture.uuid }:${ texture.version }` : null;\r\n\r\n}\r\n\r\nfunction assignOptions( target, options ) {\r\n\r\n\tfor ( const key in options ) {\r\n\r\n\t\tif ( key in target ) {\r\n\r\n\t\t\ttarget[ key ] = options[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\r\n\r\n\tconstructor( width, height, options ) {\r\n\r\n\t\tconst textureOptions = {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: HalfFloatType,\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\twrapS: RepeatWrapping,\r\n\t\t\twrapT: RepeatWrapping,\r\n\t\t\tgenerateMipmaps: false,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tsuper( width, height, 1, textureOptions );\r\n\r\n\t\t// manually assign the options because passing options into the\r\n\t\t// constructor does not work\r\n\t\tassignOptions( this.texture, textureOptions );\r\n\r\n\t\tthis.texture.setTextures = ( ...args ) => {\r\n\r\n\t\t\tthis.setTextures( ...args );\r\n\r\n\t\t};\r\n\r\n\t\tthis.hashes = [ null ];\r\n\r\n\t\tconst fsQuad = new FullScreenQuad( new CopyMaterial() );\r\n\t\tthis.fsQuad = fsQuad;\r\n\r\n\t}\r\n\r\n\tsetTextures( renderer, textures, width = this.width, height = this.height ) {\r\n\r\n\t\t// save previous renderer state\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevToneMapping = renderer.toneMapping;\r\n\t\tconst prevAlpha = renderer.getClearAlpha();\r\n\t\trenderer.getClearColor( prevColor );\r\n\r\n\t\t// resize the render target and ensure we don't have an empty texture\r\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\r\n\t\tconst depth = textures.length || 1;\r\n\t\tif ( width !== this.width || height !== this.height || this.depth !== depth ) {\r\n\r\n\t\t\tthis.setSize( width, height, depth );\r\n\t\t\tthis.hashes = new Array( depth ).fill( null );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setClearColor( 0, 0 );\r\n\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t// render each texture into each layer of the target\r\n\t\tconst fsQuad = this.fsQuad;\r\n\t\tconst hashes = this.hashes;\r\n\t\tlet updated = false;\r\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\r\n\r\n\t\t\tconst texture = textures[ i ];\r\n\t\t\tconst hash = getTextureHash( texture );\r\n\t\t\tif ( texture && ( hashes[ i ] !== hash || texture.isWebGLRenderTarget ) ) {\r\n\r\n\t\t\t\t// revert to default texture transform before rendering\r\n\t\t\t\ttexture.matrixAutoUpdate = false;\r\n\t\t\t\ttexture.matrix.identity();\r\n\r\n\t\t\t\tfsQuad.material.map = texture;\r\n\r\n\t\t\t\trenderer.setRenderTarget( this, i );\r\n\t\t\t\tfsQuad.render( renderer );\r\n\r\n\t\t\t\t// restore custom texture transform\r\n\t\t\t\ttexture.updateMatrix();\r\n\t\t\t\ttexture.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t// ensure textures are not updated unnecessarily\r\n\t\t\t\thashes[ i ] = hash;\r\n\t\t\t\tupdated = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the renderer\r\n\t\tfsQuad.material.map = null;\r\n\t\trenderer.setClearColor( prevColor, prevAlpha );\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.toneMapping = prevToneMapping;\r\n\r\n\t\treturn updated;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tsuper.dispose();\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass CopyMaterial extends ShaderMaterial {\r\n\r\n\tget map() {\r\n\r\n\t\treturn this.uniforms.map.value;\r\n\r\n\t}\r\n\tset map( v ) {\r\n\r\n\t\tthis.uniforms.map.value = v;\r\n\r\n\t}\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tmap: { value: null },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\tuniform sampler2D map;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nexport function shuffle( arr, random = Math.random() ) {\r\n\r\n\tfor ( let i = arr.length - 1; i > 0; i -- ) {\r\n\r\n\t  const j = Math.floor( random() * ( i + 1 ) );\r\n\t  const x = arr[ i ];\r\n\t  arr[ i ] = arr[ j ];\r\n\t  arr[ j ] = x;\r\n\r\n\t}\r\n\r\n\treturn arr;\r\n\r\n}\r\n\r\n// strataCount : The number of bins per dimension\r\n// dimensions  : The number of dimensions to generate stratified values for\r\nexport class StratifiedSampler {\r\n\r\n\tconstructor( strataCount, dimensions, random = Math.random ) {\r\n\r\n\t\tconst l = strataCount ** dimensions;\r\n\t\tconst strata = new Uint16Array( l );\r\n\t\tlet index = l;\r\n\r\n\t\t// each integer represents a statum bin\r\n\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tstrata[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = new Float32Array( dimensions );\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\t\tstrata[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tconst { samples } = this;\r\n\r\n\t\t\tif ( index >= strata.length ) {\r\n\r\n\t\t\t\tshuffle( strata, random );\r\n\t\t\t\tthis.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet stratum = strata[ index ++ ];\r\n\r\n\t\t\tfor ( let i = 0; i < dimensions; i ++ ) {\r\n\r\n\t\t\t\tsamples[ i ] = ( stratum % strataCount + random() ) / strataCount;\r\n\t\t\t\tstratum = Math.floor( stratum / strataCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn samples;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nimport { StratifiedSampler } from './StratifiedSampler.js';\r\n\r\n// Stratified set of data with each tuple stratified separately and combined\r\nexport class StratifiedSamplerCombined {\r\n\r\n\tconstructor( strataCount, listOfDimensions, random = Math.random ) {\r\n\r\n\t\tlet totalDim = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\ttotalDim += dim;\r\n\r\n\t\t}\r\n\r\n\t\tconst combined = new Float32Array( totalDim );\r\n\t\tconst strataObjs = [];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\tconst sampler = new StratifiedSampler( strataCount, dim, random );\r\n\t\t\tsampler.samples = new Float32Array( combined.buffer, offset, sampler.samples.length );\r\n\t\t\toffset += sampler.samples.length * 4;\r\n\t\t\tstrataObjs.push( sampler );\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = combined;\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.next();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn combined;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reset();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat } from 'three';\r\nimport { StratifiedSamplerCombined } from './stratified/StratifiedSamplerCombined.js';\r\n\r\n// https://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator\r\nclass RandomGenerator {\r\n\r\n\tconstructor( seed = 0 ) {\r\n\r\n\t\t// LCG using GCC's constants\r\n\t\tthis.m = 0x80000000; // 2**31;\r\n\t\tthis.a = 1103515245;\r\n\t\tthis.c = 12345;\r\n\r\n\t\tthis.seed = seed;\r\n\r\n\t}\r\n\r\n\tnextInt() {\r\n\r\n\t\tthis.seed = ( this.a * this.seed + this.c ) % this.m;\r\n\t\treturn this.seed;\r\n\r\n\t}\r\n\r\n\tnextFloat() {\r\n\r\n\t\t// returns in range [0,1]\r\n\t\treturn this.nextInt() / ( this.m - 1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class StratifiedSamplesTexture extends DataTexture {\r\n\r\n\tconstructor( count = 1, depth = 1, strata = 8 ) {\r\n\r\n\t\tsuper( new Float32Array( 1 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.strata = strata;\r\n\t\tthis.sampler = null;\r\n\t\tthis.generator = new RandomGenerator();\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.random = () => {\r\n\r\n\t\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\t\treturn this.generator.nextFloat();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn Math.random();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.init( count, depth, strata );\r\n\r\n\t}\r\n\r\n\tinit( count = this.image.height, depth = this.image.width, strata = this.strata ) {\r\n\r\n\t\tconst { image } = this;\r\n\t\tif ( image.width === depth && image.height === count && this.sampler !== null ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst dimensions = new Array( count * depth ).fill( 4 );\r\n\t\tconst sampler = new StratifiedSamplerCombined( strata, dimensions, this.random );\r\n\r\n\t\timage.width = depth;\r\n\t\timage.height = count;\r\n\t\timage.data = sampler.samples;\r\n\r\n\t\tthis.sampler = sampler;\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.next();\r\n\r\n\t}\r\n\r\n\tnext() {\r\n\r\n\t\tthis.sampler.next();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.sampler.reset();\r\n\t\tthis.generator.seed = 0;\r\n\r\n\t}\r\n\r\n}\r\n","export function shuffleArray( array, random = Math.random ) {\r\n\r\n\tfor ( let i = array.length - 1; i > 0; i -- ) {\r\n\r\n\t\tconst replaceIndex = ~ ~ ( ( random() - 1e-6 ) * i );\r\n\t\tconst tmp = array[ i ];\r\n\t\tarray[ i ] = array[ replaceIndex ];\r\n\t\tarray[ replaceIndex ] = tmp;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function fillWithOnes( array, count ) {\r\n\r\n\tarray.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tarray[ i ] = 1;\r\n\r\n\t}\r\n\r\n}\r\n","export class BlueNoiseSamples {\r\n\r\n\tconstructor( size ) {\r\n\r\n\t\tthis.count = 0;\r\n\t\tthis.size = - 1;\r\n\t\tthis.sigma = - 1;\r\n\t\tthis.radius = - 1;\r\n\t\tthis.lookupTable = null;\r\n\t\tthis.score = null;\r\n\t\tthis.binaryPattern = null;\r\n\r\n\t\tthis.resize( size );\r\n\t\tthis.setSigma( 1.5 );\r\n\r\n\t}\r\n\r\n\tfindVoid() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 0 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore < currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tfindCluster() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = - Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 1 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore > currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tsetSigma( sigma ) {\r\n\r\n\t\tif ( sigma === this.sigma ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// generate a radius in which the score will be updated under the\r\n\t\t// assumption that e^-10 is insignificant enough to be the border at\r\n\t\t// which we drop off.\r\n\t\tconst radius = ~ ~ ( Math.sqrt( 10 * 2 * ( sigma ** 2 ) ) + 1 );\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tconst lookupTable = new Float32Array( lookupWidth * lookupWidth );\r\n\t\tconst sigma2 = sigma * sigma;\r\n\t\tfor ( let x = - radius; x <= radius; x ++ ) {\r\n\r\n\t\t\tfor ( let y = - radius; y <= radius; y ++ ) {\r\n\r\n\t\t\t\tconst index = ( radius + y ) * lookupWidth + x + radius;\r\n\t\t\t\tconst dist2 = x * x + y * y;\r\n\t\t\t\tlookupTable[ index ] = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.lookupTable = lookupTable;\r\n\t\tthis.sigma = sigma;\r\n\t\tthis.radius = radius;\r\n\r\n\t}\r\n\r\n\tresize( size ) {\r\n\r\n\t\tif ( this.size !== size ) {\r\n\r\n\t\t\tthis.size = size;\r\n\t\t\tthis.score = new Float32Array( size * size );\r\n\t\t\tthis.binaryPattern = new Uint8Array( size * size );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\tconst { binaryPattern, score, size } = this;\r\n\r\n\t\tscore.fill( 0 );\r\n\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] === 0 ) {\r\n\r\n\t\t\t\tconst y = ~ ~ ( i / size );\r\n\t\t\t\tconst x = i - y * size;\r\n\t\t\t\tthis.updateScore( x, y, 1 );\r\n\t\t\t\tbinaryPattern[ i ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinaryPattern[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateScore( x, y, multiplier ) {\r\n\r\n\t\t// TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\r\n\t\t// everything in the buffer?\r\n\t\tconst { size, score, lookupTable } = this;\r\n\r\n\t\t// const sigma2 = sigma * sigma;\r\n\t\t// const radius = Math.floor( size / 2 );\r\n\t\tconst radius = this.radius;\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tfor ( let px = - radius; px <= radius; px ++ ) {\r\n\r\n\t\t\tfor ( let py = - radius; py <= radius; py ++ ) {\r\n\r\n\t\t\t\t// const dist2 = px * px + py * py;\r\n\t\t\t\t// const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t\tconst lookupIndex = ( radius + py ) * lookupWidth + px + radius;\r\n\t\t\t\tconst value = lookupTable[ lookupIndex ];\r\n\r\n\t\t\t\tlet sx = ( x + px );\r\n\t\t\t\tsx = sx < 0 ? size + sx : sx % size;\r\n\r\n\t\t\t\tlet sy = ( y + py );\r\n\t\t\t\tsy = sy < 0 ? size + sy : sy % size;\r\n\r\n\t\t\t\tconst sindex = sy * size + sx;\r\n\t\t\t\tscore[ sindex ] += multiplier * value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\taddPointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 1;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, 1 );\r\n\t\tthis.count ++;\r\n\r\n\t}\r\n\r\n\tremovePointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 0;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, - 1 );\r\n\t\tthis.count --;\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.resize( source.size );\r\n\t\tthis.score.set( source.score );\r\n\t\tthis.binaryPattern.set( source.binaryPattern );\r\n\t\tthis.setSigma( source.sigma );\r\n\t\tthis.count = source.count;\r\n\r\n\t}\r\n\r\n}\r\n","import { shuffleArray, fillWithOnes } from './utils.js';\r\nimport { BlueNoiseSamples } from './BlueNoiseSamples.js';\r\n\r\nexport class BlueNoiseGenerator {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.random = Math.random;\r\n\t\tthis.sigma = 1.5;\r\n\t\tthis.size = 64;\r\n\t\tthis.majorityPointsRatio = 0.1;\r\n\r\n\t\tthis.samples = new BlueNoiseSamples( 1 );\r\n\t\tthis.savedSamples = new BlueNoiseSamples( 1 );\r\n\r\n\t}\r\n\r\n\tgenerate() {\r\n\r\n\t\t// http://cv.ulichney.com/papers/1993-void-cluster.pdf\r\n\r\n\t\tconst {\r\n\t\t\tsamples,\r\n\t\t\tsavedSamples,\r\n\t\t\tsigma,\r\n\t\t\tmajorityPointsRatio,\r\n\t\t\tsize,\r\n\t\t} = this;\r\n\r\n\t\tsamples.resize( size );\r\n\t\tsamples.setSigma( sigma );\r\n\r\n\t\t// 1. Randomly place the minority points.\r\n\t\tconst pointCount = Math.floor( size * size * majorityPointsRatio );\r\n\t\tconst initialSamples = samples.binaryPattern;\r\n\r\n\t\tfillWithOnes( initialSamples, pointCount );\r\n\t\tshuffleArray( initialSamples, this.random );\r\n\r\n\t\tfor ( let i = 0, l = initialSamples.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( initialSamples[ i ] === 1 ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 2. Remove minority point that is in densest cluster and place it in the largest void.\r\n\t\twhile ( true ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tconst voidIndex = samples.findVoid();\r\n\t\t\tif ( clusterIndex === voidIndex ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( clusterIndex );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsamples.addPointIndex( voidIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\r\n\t\t// in the dither array.\r\n\t\tconst ditherArray = new Uint32Array( size * size );\r\n\t\tsavedSamples.copy( samples );\r\n\r\n\t\tlet rank;\r\n\t\trank = samples.count - 1;\r\n\t\twhile ( rank >= 0 ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank --;\r\n\r\n\t\t}\r\n\r\n\t\t// 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\r\n\t\t// the initial binary pattern.\r\n\t\tconst totalSize = size * size;\r\n\t\trank = savedSamples.count;\r\n\t\twhile ( rank < totalSize / 2 ) {\r\n\r\n\t\t\tconst voidIndex = savedSamples.findVoid();\r\n\t\t\tsavedSamples.addPointIndex( voidIndex );\r\n\t\t\tditherArray[ voidIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\t// 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\r\n\t\t// and iteratively removing them.\r\n\t\tsavedSamples.invert();\r\n\r\n\t\twhile ( rank < totalSize ) {\r\n\r\n\t\t\tconst clusterIndex = savedSamples.findCluster();\r\n\t\t\tsavedSamples.removePointIndex( clusterIndex );\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { data: ditherArray, maxValue: totalSize };\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat, RGFormat, RedFormat } from 'three';\r\nimport { BlueNoiseGenerator } from './blueNoise/BlueNoiseGenerator.js';\r\n\r\nfunction getStride( channels ) {\r\n\r\n\tif ( channels >= 3 ) {\r\n\r\n\t\treturn 4;\r\n\r\n\t} else {\r\n\r\n\t\treturn channels;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getFormat( channels ) {\r\n\r\n\tswitch ( channels ) {\r\n\r\n\tcase 1:\r\n\t\treturn RedFormat;\r\n\tcase 2:\r\n\t\treturn RGFormat;\r\n\tdefault:\r\n\t\treturn RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class BlueNoiseTexture extends DataTexture {\r\n\r\n\tconstructor( size = 64, channels = 1 ) {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.size = size;\r\n\t\tthis.channels = channels;\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst channels = this.channels;\r\n\t\tconst size = this.size;\r\n\t\tconst generator = new BlueNoiseGenerator();\r\n\t\tgenerator.channels = channels;\r\n\t\tgenerator.size = size;\r\n\r\n\t\tconst stride = getStride( channels );\r\n\t\tconst format = getFormat( stride );\r\n\t\tif ( this.image.width !== size || format !== this.format ) {\r\n\r\n\t\t\tthis.image.width = size;\r\n\t\t\tthis.image.height = size;\r\n\t\t\tthis.image.data = new Float32Array( ( size ** 2 ) * stride );\r\n\t\t\tthis.format = format;\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tconst data = this.image.data;\r\n\t\tfor ( let i = 0, l = channels; i < l; i ++ ) {\r\n\r\n\t\t\tconst result = generator.generate();\r\n\t\t\tconst bin = result.data;\r\n\t\t\tconst maxValue = result.maxValue;\r\n\r\n\t\t\tfor ( let j = 0, l2 = bin.length; j < l2; j ++ ) {\r\n\r\n\t\t\t\tconst value = bin[ j ] / maxValue;\r\n\t\t\t\tdata[ j * stride + i ] = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n","export const fresnel_functions = /* glsl */`\r\n\r\n\tbool totalInternalReflection( float cosTheta, float eta ) {\r\n\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\treturn eta * sinTheta > 1.0;\r\n\r\n\t}\r\n\r\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\r\n\tfloat schlickFresnel( float cosine, float f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\r\n\r\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat ni = eta;\r\n\t\tfloat nt = 1.0;\r\n\r\n\t\t// Check for total internal reflection\r\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\r\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\r\n\t\tif( sinThetaTSq >= 1.0 ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\r\n\r\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\r\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\r\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\r\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\r\n\r\n\t}\r\n\r\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\r\n\tfloat iorRatioToF0( float eta ) {\r\n\r\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\r\n\r\n\t}\r\n\r\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\r\n\r\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t\t\treturn f90;\r\n\r\n\t\t}\r\n\r\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\r\n\r\n\t}\r\n\r\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\r\n\t// the glTF but is causing blown out pixels. Should be revisited\r\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\r\n\r\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t// \t\treturn 1.0;\r\n\r\n\t// \t}\r\n\r\n\t// \treturn schlickFresnel( cosTheta, f0 );\r\n\r\n\t// }\r\n\r\n\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\r\n\r\n\t\tfloat dotHV = dot( wo, wh );\r\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat dotHL = dot( wi, wh );\r\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\r\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\r\n\r\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\r\n\r\n\t}\r\n\r\n`;\r\n","export const shape_intersection_functions = /* glsl */`\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the rectangle on that same plane.\r\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\r\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = p - center;\r\n\r\n\t\t\t// check if p falls inside the rectangle\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\r\n\r\n\t\t\t\tfloat a2 = dot( v, vi );\r\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\r\n\r\n\t\t\t\t\tdist = t;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\r\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = hit - position;\r\n\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tfloat a2 = dot( v, vi );\r\n\r\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\r\n\r\n\t\t\t\tdist = t;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const texture_sample_functions = /*glsl */`\r\n\r\n\t// add texel fetch functions for texture arrays\r\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\r\n\r\n\t\tuint width = uint( textureSize( tex, 0 ).x );\r\n\t\tuvec2 uv;\r\n\t\tuv.x = index % width;\r\n\t\tuv.y = index / width;\r\n\r\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\r\n\r\n\t}\r\n\r\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\t\treturn\r\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\r\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\r\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\r\n\r\n\t}\r\n\r\n`;\r\n","/*\r\nwi     : incident vector or light vector (pointing toward the light)\r\nwo     : outgoing vector or view vector (pointing towards the camera)\r\nwh     : computed half vector from wo and wi\r\nEval   : Get the color and pdf for a direction\r\nSample : Get the direction, color, and pdf for a sample\r\neta    : Greek character used to denote the \"ratio of ior\"\r\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\r\nf90    : Amount of light reflected at grazing angles\r\n*/\r\n\r\nexport const bsdf_functions = /* glsl */`\r\n\r\n\t// diffuse\r\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\r\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\r\n\r\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\r\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\r\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\r\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\r\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\r\n\r\n\t\t// TODO: subsurface approx?\r\n\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\r\n\r\n\t\treturn wi.z / PI;\r\n\r\n\t}\r\n\r\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\r\n\t\tlightDirection.z += 1.0;\r\n\t\tlightDirection = normalize( lightDirection );\r\n\r\n\t\treturn lightDirection;\r\n\r\n\t}\r\n\r\n\t// specular\r\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\r\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\r\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\r\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\r\n\r\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\r\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\r\n\r\n\t\t// PDF\r\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\r\n\t\tfloat incidentTheta = acos( wo.z );\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\t\tfloat denomZ = max( abs( wo.z ), 1e-7 );\r\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / denomZ;\r\n\r\n\t\tcolor = wi.z * F * G * D / max( 4.0 * abs( wi.z * wo.z ), 1e-7 );\r\n\t\treturn ggxPdf / max( 4.0 * abs( dot( wo, wh ) ), 1e-7 );\r\n\r\n\t}\r\n\r\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 12 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\r\n\t// transmission\r\n\t/*\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tbool thinFilm = surf.thinFilm;\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\r\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / max( denom, 1e-7 );\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( filteredRoughness ),\r\n\t\t\trand2( 13 )\r\n\t\t);\r\n\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\t*/\r\n\r\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\r\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\t// PDF\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\t// if ( F >= 1.0 ) {\r\n\r\n\t\t// \treturn 0.0;\r\n\r\n\t\t// }\r\n\r\n\t\t// return 1.0 / ( 1.0 - F );\r\n\r\n\t\t// reverted to previous to transmission. The above was causing black pixels\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\t\tfloat cosTheta = min( wo.z, 1.0 );\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\r\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\r\n\t\tif ( cannotRefract ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 1.0 - reflectance );\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\r\n\t// clearcoat\r\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tfloat ior = 1.5;\r\n\t\tfloat f0 = iorRatioToF0( ior );\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\r\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\r\n\r\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\r\n\r\n\t\t// PDF\r\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\r\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 14 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\t// sheen\r\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\r\n\r\n\t\tfloat cosThetaO = saturateCos( wo.z );\r\n\t\tfloat cosThetaI = saturateCos( wi.z );\r\n\t\tfloat cosThetaH = wh.z;\r\n\r\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\r\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\r\n\r\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\t\tvec3 color = surf.sheenColor;\r\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\r\n\t\tcolor *= wi.z;\r\n\r\n\t\treturn color;\r\n\r\n\t}\r\n\r\n\t// bsdf\r\n\tvoid getLobeWeights(\r\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\r\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\r\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\r\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\r\n\r\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\r\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\r\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\r\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\r\n\r\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\r\n\t\tdiffuseWeight /= totalWeight;\r\n\t\tspecularWeight /= totalWeight;\r\n\t\ttransmissionWeight /= totalWeight;\r\n\t\tclearcoatWeight /= totalWeight;\r\n\t}\r\n\r\n\tfloat bsdfEval(\r\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\r\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\r\n\t\tfloat spdf = 0.0;\r\n\t\tfloat dpdf = 0.0;\r\n\t\tfloat tpdf = 0.0;\r\n\t\tfloat cpdf = 0.0;\r\n\t\tcolor = vec3( 0.0 );\r\n\r\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\r\n\r\n\t\t// diffuse\r\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\r\n\t\t\tcolor *= 1.0 - surf.transmission;\r\n\r\n\t\t}\r\n\r\n\t\t// ggx specular\r\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tvec3 outColor;\r\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\r\n\t\t\tcolor += outColor;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\r\n\r\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\t// sheen\r\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\r\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\r\n\r\n\t\t// clearcoat\r\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\r\n\r\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\r\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\tfloat pdf =\r\n\t\t\tdpdf * diffuseWeight\r\n\t\t\t+ spdf * specularWeight\r\n\t\t\t+ tpdf * transmissionWeight\r\n\t\t\t+ cpdf * clearcoatWeight;\r\n\r\n\t\t// retrieve specular rays for the shadows flag\r\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\r\n\r\n\t\treturn pdf;\r\n\r\n\t}\r\n\r\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tcolor = surf.color / ( 4.0 * PI );\r\n\t\t\treturn 1.0 / ( 4.0 * PI );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\r\n\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\r\n\r\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat specularPdf;\r\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\r\n\r\n\t}\r\n\r\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tScatterRecord sampleRec;\r\n\t\t\tsampleRec.specularPdf = 0.0;\r\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\r\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\r\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\r\n\t\t\treturn sampleRec;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tmat3 normalBasis = surf.normalBasis;\r\n\t\tmat3 invBasis = surf.normalInvBasis;\r\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\r\n\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\r\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat pdf[4];\r\n\t\tpdf[0] = diffuseWeight;\r\n\t\tpdf[1] = specularWeight;\r\n\t\tpdf[2] = transmissionWeight;\r\n\t\tpdf[3] = clearcoatWeight;\r\n\r\n\t\tfloat cdf[4];\r\n\t\tcdf[0] = pdf[0];\r\n\t\tcdf[1] = pdf[1] + cdf[0];\r\n\t\tcdf[2] = pdf[2] + cdf[1];\r\n\t\tcdf[3] = pdf[3] + cdf[2];\r\n\r\n\t\tif( cdf[3] != 0.0 ) {\r\n\r\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\r\n\t\t\tcdf[0] *= invMaxCdf;\r\n\t\t\tcdf[1] *= invMaxCdf;\r\n\t\t\tcdf[2] *= invMaxCdf;\r\n\t\t\tcdf[3] *= invMaxCdf;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcdf[0] = 1.0;\r\n\t\t\tcdf[1] = 0.0;\r\n\t\t\tcdf[2] = 0.0;\r\n\t\t\tcdf[3] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wi;\r\n\t\tvec3 clearcoatWi;\r\n\r\n\t\tfloat r = rand( 15 );\r\n\t\tif ( r <= cdf[0] ) { // diffuse\r\n\r\n\t\t\twi = diffuseDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[1] ) { // specular\r\n\r\n\t\t\twi = specularDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\r\n\r\n\t\t\twi = transmissionDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\r\n\r\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\r\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\r\n\r\n\t\t}\r\n\r\n\t\tScatterRecord result;\r\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\r\n\t\tresult.direction = normalize( surf.normalBasis * wi );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const fog_functions = /* glsl */`\r\n\r\n\t// returns the hit distance given the material density\r\n\tfloat intersectFogVolume( Material material, float u ) {\r\n\r\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\r\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\r\n\r\n\t}\r\n\r\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\r\n\r\n\t\tScatterRecord sampleRec;\r\n\t\tsampleRec.specularPdf = 0.0;\r\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\r\n\t\tsampleRec.direction = sampleSphere( uv );\r\n\t\tsampleRec.color = surf.color;\r\n\t\treturn sampleRec;\r\n\r\n\t}\r\n\r\n`;\r\n","export const iridescence_functions = /* glsl */`\r\n\r\n\t// XYZ to sRGB color space\r\n\tconst mat3 XYZ_TO_REC709 = mat3(\r\n\t\t3.2404542, -0.9692660,  0.0556434,\r\n\t\t-1.5371385,  1.8760108, -0.2040259,\r\n\t\t-0.4985314,  0.0415560,  1.0572252\r\n\t);\r\n\r\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\r\n\r\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\r\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\r\n\r\n\t}\r\n\r\n\t// Conversion FO/IOR\r\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\r\n\r\n\t}\r\n\r\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\r\n\r\n\t}\r\n\r\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\r\n\r\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\r\n\r\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\r\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\r\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\r\n\r\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\r\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\r\n\t\txyz /= 1.0685e-7;\r\n\r\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\r\n\t\treturn srgb;\r\n\r\n\t}\r\n\r\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\r\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\r\n\r\n\t\tvec3 I;\r\n\r\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\r\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\r\n\r\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\r\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\r\n\r\n\t\t// Handle TIR:\r\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n\t\tif ( cosTheta2Sq < 0.0 ) {\r\n\r\n\t\t\treturn vec3( 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\r\n\r\n\t\t// First interface\r\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\r\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\r\n\t\tfloat R21 = R12;\r\n\t\tfloat T121 = 1.0 - R12;\r\n\t\tfloat phi12 = 0.0;\r\n\t\tif ( iridescenceIor < outsideIOR ) {\r\n\r\n\t\t\tphi12 = PI;\r\n\r\n\t\t}\r\n\r\n\t\tfloat phi21 = PI - phi12;\r\n\r\n\t\t// Second interface\r\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\r\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\r\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\r\n\t\tvec3 phi23 = vec3( 0.0 );\r\n\t\tif ( baseIOR[0] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 0 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[1] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 1 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[2] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 2 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\t// Phase shift\r\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\r\n\t\tvec3 phi = vec3( phi21 ) + phi23;\r\n\r\n\t\t// Compound terms\r\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\r\n\t\tvec3 r123 = sqrt( R123 );\r\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\r\n\r\n\t\t// Reflectance term for m = 0 (DC term amplitude)\r\n\t\tvec3 C0 = R12 + Rs;\r\n\t\tI = C0;\r\n\r\n\t\t// Reflectance term for m > 0 (pairs of diracs)\r\n\t\tvec3 Cm = Rs - T121;\r\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\r\n\r\n\t\t\tCm *= r123;\r\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\r\n\t\t\tI += Cm * Sm;\r\n\r\n\t\t}\r\n\r\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n\t\treturn max( I, vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n`;\r\n","export const sheen_functions = /* glsl */`\r\n\r\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetD( float cosThetaH, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat invAlpha = 1.0 / alpha;\r\n\r\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\r\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\r\n\r\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\r\n\r\n\t}\r\n\r\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\r\n\r\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\r\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\r\n\r\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\r\n\r\n\t}\r\n\r\n\tfloat velvetL( float x, float alpha ) {\r\n\r\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\r\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\r\n\r\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\r\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\r\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\r\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\r\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\r\n\r\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\r\n\r\n\t}\r\n\r\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetLambda( float cosTheta, float alpha ) {\r\n\r\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\r\n\r\n\t}\r\n\r\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\r\n\r\n\t}\r\n\r\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\r\n\r\n\t\tcosTheta = saturate( cosTheta );\r\n\r\n\t\tfloat c = 1.0 - cosTheta;\r\n\t\tfloat c3 = c * c * c;\r\n\r\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\r\n\r\n\t}\r\n\r\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\r\n\r\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\r\n\r\n\t}\r\n\r\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\r\n\t\treturn 1.0 - maxSheenColor * eWo;\r\n\r\n\t}\r\n\r\n`;\r\n","export const inside_fog_volume_function = /* glsl */`\r\n\r\n#ifndef FOG_CHECK_ITERATIONS\r\n#define FOG_CHECK_ITERATIONS 30\r\n#endif\r\n\r\n// returns whether the given material is a fog material or not\r\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\r\n\r\n\tuint i = materialIndex * uint( MATERIAL_PIXELS );\r\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\r\n\treturn bool( int( s14.b ) & 4 );\r\n\r\n}\r\n\r\n// returns true if we're within the first fog volume we hit\r\nbool bvhIntersectFogVolumeHit(\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\tusampler2D materialIndexAttribute, sampler2D materials,\r\n\tinout Material material\r\n) {\r\n\r\n\tmaterial.fogVolume = false;\r\n\r\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\r\n\r\n\t\t// find nearest hit\r\n\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\tfloat side = 1.0;\r\n\t\tfloat dist = 0.0;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\t\tif ( hit ) {\r\n\r\n\t\t\t// if it's a fog volume return whether we hit the front or back face\r\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\r\n\r\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\r\n\t\t\t\treturn side == - 1.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// move the ray forward\r\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n`;\r\n","export const attenuate_hit_function = /* glsl */`\r\n\r\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\r\n\t// returns true if a solid surface was hit\r\n\tbool attenuateHit(\r\n\t\tRenderState state,\r\n\t\tRay ray, float rayDist,\r\n\t\tout vec3 color\r\n\t) {\r\n\r\n\t\t// store the original bounce index so we can reset it after\r\n\t\tuint originalBounceIndex = sobolBounceIndex;\r\n\r\n\t\tint traversals = state.traversals;\r\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\r\n\t\tbool isShadowRay = state.isShadowRay;\r\n\t\tMaterial fogMaterial = state.fogMaterial;\r\n\r\n\t\tvec3 startPoint = ray.origin;\r\n\r\n\t\t// hit results\r\n\t\tSurfaceHit surfaceHit;\r\n\r\n\t\tcolor = vec3( 1.0 );\r\n\r\n\t\tbool result = true;\r\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\r\n\r\n\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\r\n\r\n\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\tresult = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\r\n\r\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\r\n\t\t\t\tif ( totalDist > rayDist ) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\r\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\r\n\t\t\t\t// TODO: should we account for emissive surfaces here?\r\n\r\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t// adjust the ray to the new surface\r\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\r\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\t\t\tfogMaterial = material;\r\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t\t\t// albedo\r\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\t\t\talbedo *= vertexColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// alphaMap\r\n\t\t\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transmission\r\n\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// metalness\r\n\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\r\n\t\t\t\tif (\r\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\r\n\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\r\n\r\n\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tresult = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\r\n\r\n\t\t\t\t\t// only attenuate by surface color on the way in\r\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\r\n\r\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\r\n\r\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\r\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the bounce index\r\n\t\tsobolBounceIndex = originalBounceIndex;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const camera_util_functions = /* glsl */`\r\n\r\n\tvec3 ndcToRayOrigin( vec2 coord ) {\r\n\r\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\r\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\r\n\t}\r\n\r\n\tRay getCameraRay() {\r\n\r\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\r\n\r\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\r\n\t\t// around this pixel's UV coordinate for AA\r\n\t\tvec2 ruv = rand2( 0 );\r\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\r\n\t\tRay ray;\r\n\r\n\t\t#if CAMERA_TYPE == 2\r\n\r\n\t\t\t// Equirectangular projection\r\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\r\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\r\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\r\n\r\n\t\t\tray.direction = normalize( rayDirection4.xyz );\r\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\r\n\r\n\t\t#else\r\n\r\n\t\t\t// get [- 1, 1] normalized device coordinates\r\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\r\n\t\t\tray.origin = ndcToRayOrigin( ndc );\r\n\r\n\t\t\t#if CAMERA_TYPE == 1\r\n\r\n\t\t\t\t// Orthographic projection\r\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\r\n\t\t\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// Perspective projection\r\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\r\n\t\t#if FEATURE_DOF\r\n\t\t{\r\n\r\n\t\t\t// depth of field\r\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\r\n\r\n\t\t\t// get the aperture sample\r\n\t\t\t// if blades === 0 then we assume a circle\r\n\t\t\tvec3 shapeUVW= rand3( 1 );\r\n\t\t\tint blades = physicalCamera.apertureBlades;\r\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\r\n\t\t\tvec2 apertureSample = sampleAperture( blades, shapeUVW );\r\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\r\n\r\n\t\t\t// rotate the aperture shape\r\n\t\t\tapertureSample =\r\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\r\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\r\n\r\n\t\t\t// create the new ray\r\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\r\n\t\t\tray.direction = focalPoint - ray.origin;\r\n\t\t\t// avoid division by zero in normalize when origin equals focal point\r\n\t\t\tfloat dirLen = length( ray.direction );\r\n\t\t\tif ( dirLen < 1e-6 ) {\r\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\r\n\t\t\t\tray.direction = normalize( ray.direction );\r\n\t\t\t} else {\r\n\t\t\t\tray.direction /= dirLen;\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endif\r\n\r\n\t\t#if FEATURE_DOF == 0\r\n\t\tray.direction = normalize( ray.direction );\r\n\t\t#endif\r\n\r\n\t\treturn ray;\r\n\r\n\t}\r\n\r\n`;\r\n","export const direct_light_contribution_function = /*glsl*/`\r\n\r\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\r\n\r\n\t\tvec3 result = vec3( 0.0 );\r\n\r\n\t\t// uniformly pick a light or environment map\r\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\r\n\r\n\t\t\t// sample a light or environment\r\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\r\n\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tlightRec.pdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the light area\r\n\t\t\tRay lightRay;\r\n\t\t\tlightRay.origin = rayOrigin;\r\n\t\t\tlightRay.direction = lightRec.direction;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tlightRec.pdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\r\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\r\n\r\n\t\t\t// find a sample in the environment map to include in the contribution\r\n\t\t\tvec3 envColor, envDirection;\r\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\r\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\r\n\r\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\r\n\t\t\t// results so we ignore the sample in this case.\r\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tenvPdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the surface\r\n\t\t\tRay envRay;\r\n\t\t\tenvRay.origin = rayOrigin;\r\n\t\t\tenvRay.direction = envDirection;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tenvPdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tenvPdf /= lightsDenom;\r\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * applyEnvSaturation( envColor ) * state.throughputColor * sampleColor * misWeight / envPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\r\n\t\t// See issue #470\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const get_surface_record_function = /* glsl */`\r\n\r\n\t#define SKIP_SURFACE 0\r\n\t#define HIT_SURFACE 1\r\n\tint getSurfaceRecord(\r\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\r\n\t\tfloat accumulatedRoughness,\r\n\t\tinout SurfaceRecord surf\r\n\t) {\r\n\r\n\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\r\n\r\n\t\t\tSurfaceRecord fogSurface;\r\n\t\t\tfogSurface.volumeParticle = true;\r\n\t\t\tfogSurface.color = material.color;\r\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\r\n\t\t\tfogSurface.normal = normal;\r\n\t\t\tfogSurface.faceNormal = normal;\r\n\t\t\tfogSurface.clearcoatNormal = normal;\r\n\r\n\t\t\tsurf = fogSurface;\r\n\t\t\treturn HIT_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// uv coord for textures\r\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t// albedo\r\n\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\talbedo *= vertexColor;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMap\r\n\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t}\r\n\r\n\t\t// Hit flag: SKIP_SURFACE = continue ray (transparent); HIT_SURFACE = shade. Solid ground uses hit-flag + alpha\r\n\t\t// (alpha test or stochastic alpha for PNG transparency) + transmission (refraction/tint in attenuateHit).\r\n\t\t// Possibly skip if transparent, alpha test enabled, or wrong material side (single sided).\r\n\t\t// - alpha test disabled when === 0; stochastic alpha: material.transparent && albedo.a < rand(3).\r\n\t\t// - material sidedness: allow light through back side but still shade front; skip wrong side on first ray.\r\n\t\tfloat alphaTest = material.alphaTest;\r\n\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\tif (\r\n\t\t\t// material sidedness\r\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\r\n\r\n\t\t\t// alpha test\r\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t// opacity\r\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\r\n\t\t) {\r\n\r\n\t\t\treturn SKIP_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// fetch the interpolated smooth normal\r\n\t\tvec3 normal = normalize( textureSampleBarycoord(\r\n\t\t\tattributesArray,\r\n\t\t\tATTR_NORMAL,\r\n\t\t\tsurfaceHit.barycoord,\r\n\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t).xyz );\r\n\r\n\t\t// roughness\r\n\t\tfloat roughness = material.roughness;\r\n\t\tif ( material.roughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\r\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// metalness\r\n\t\tfloat metalness = material.metalness;\r\n\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t}\r\n\r\n\t\t// emission\r\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\r\n\t\tif ( material.emissiveMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\r\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tfloat transmission = material.transmission;\r\n\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// normal\r\n\t\tif ( material.flatShading ) {\r\n\r\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\r\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\r\n\t\t\t// interpolated vertex normals.\r\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 baseNormal = normal;\r\n\t\tif ( material.normalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.normalScale;\r\n\t\t\t\tnormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnormal *= surfaceHit.side;\r\n\r\n\t\t// clearcoat\r\n\t\tfloat clearcoat = material.clearcoat;\r\n\t\tif ( material.clearcoatMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatRoughness\r\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\r\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatNormal\r\n\t\tvec3 clearcoatNormal = baseNormal;\r\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\r\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclearcoatNormal *= surfaceHit.side;\r\n\r\n\t\t// sheenColor\r\n\t\tvec3 sheenColor = material.sheenColor;\r\n\t\tif ( material.sheenColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// sheenRoughness\r\n\t\tfloat sheenRoughness = material.sheenRoughness;\r\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence = material.iridescence;\r\n\t\tif ( material.iridescenceMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\r\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence thickness\r\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\r\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\r\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\r\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\r\n\r\n\t\t}\r\n\r\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\r\n\r\n\t\t// specular color\r\n\t\tvec3 specularColor = material.specularColor;\r\n\t\tif ( material.specularColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// specular intensity\r\n\t\tfloat specularIntensity = material.specularIntensity;\r\n\t\tif ( material.specularIntensityMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\tsurf.volumeParticle = false;\r\n\r\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\r\n\t\tsurf.normal = normal;\r\n\r\n\t\tsurf.metalness = metalness;\r\n\t\tsurf.color = albedo.rgb;\r\n\t\tsurf.emission = emission;\r\n\r\n\t\tsurf.ior = material.ior;\r\n\t\tsurf.transmission = transmission;\r\n\t\tsurf.thinFilm = material.thinFilm;\r\n\t\tsurf.attenuationColor = material.attenuationColor;\r\n\t\tsurf.attenuationDistance = material.attenuationDistance;\r\n\r\n\t\tsurf.clearcoatNormal = clearcoatNormal;\r\n\t\tsurf.clearcoat = clearcoat;\r\n\r\n\t\tsurf.sheen = material.sheen;\r\n\t\tsurf.sheenColor = sheenColor;\r\n\r\n\t\tsurf.iridescence = iridescence;\r\n\t\tsurf.iridescenceIor = material.iridescenceIor;\r\n\t\tsurf.iridescenceThickness = iridescenceThickness;\r\n\r\n\t\tsurf.specularColor = specularColor;\r\n\t\tsurf.specularIntensity = specularIntensity;\r\n\r\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\r\n\t\t// applied by its brdf function\r\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\r\n\t\tsurf.roughness = roughness * roughness;\r\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\r\n\t\tsurf.sheenRoughness = sheenRoughness;\r\n\r\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\r\n\t\t// then we can just always assume this is a front face.\r\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\r\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\r\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\r\n\r\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\r\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\r\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\r\n\t\t// sharp internal reflections\r\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\r\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\r\n\r\n\t\t// get the normal frames\r\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\r\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\r\n\r\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\r\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\r\n\r\n\t\treturn HIT_SURFACE;\r\n\r\n\t}\r\n`;\r\n","export const render_structs = /* glsl */`\r\n\r\n\tstruct Ray {\r\n\r\n\t\tvec3 origin;\r\n\t\tvec3 direction;\r\n\r\n\t};\r\n\r\n\tstruct SurfaceHit {\r\n\r\n\t\tuvec4 faceIndices;\r\n\t\tvec3 barycoord;\r\n\t\tvec3 faceNormal;\r\n\t\tfloat side;\r\n\t\tfloat dist;\r\n\r\n\t};\r\n\r\n\tstruct RenderState {\r\n\r\n\t\tbool firstRay;\r\n\t\tbool transmissiveRay;\r\n\t\tbool isShadowRay;\r\n\t\tfloat accumulatedRoughness;\r\n\t\tint transmissiveTraversals;\r\n\t\tint traversals;\r\n\t\tuint depth;\r\n\t\tvec3 throughputColor;\r\n\t\tMaterial fogMaterial;\r\n\r\n\t};\r\n\r\n\tRenderState initRenderState() {\r\n\r\n\t\tRenderState result;\r\n\t\tresult.firstRay = true;\r\n\t\tresult.transmissiveRay = true;\r\n\t\tresult.isShadowRay = false;\r\n\t\tresult.accumulatedRoughness = 0.0;\r\n\t\tresult.transmissiveTraversals = 0;\r\n\t\tresult.traversals = 0;\r\n\t\tresult.throughputColor = vec3( 1.0 );\r\n\t\tresult.depth = 0u;\r\n\t\tresult.fogMaterial.fogVolume = false;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const trace_scene_function = /* glsl */`\r\n\r\n\t#define NO_HIT 0\r\n\t#define SURFACE_HIT 1\r\n\t#define LIGHT_HIT 2\r\n\t#define FOG_HIT 3\r\n\r\n\t// Passing the global variable 'lights' into this function caused shader program errors.\r\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\r\n\t// For more information, refer to: https://github.com/gkjohnson/three-gpu-pathtracer/pull/457\r\n\tint traceScene(\r\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\r\n\t) {\r\n\r\n\t\tint result = NO_HIT;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\r\n\r\n\t\t#if FEATURE_FOG\r\n\r\n\t\tif ( fogMaterial.fogVolume ) {\r\n\r\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\r\n\t\t\t// as other objects\r\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\r\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\r\n\r\n\t\t\t\tsurfaceHit.side = 1.0;\r\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\r\n\t\t\t\tsurfaceHit.dist = particleDist;\r\n\t\t\t\treturn FOG_HIT;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t\tif ( hit ) {\r\n\r\n\t\t\tresult = SURFACE_HIT;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","import { ClampToEdgeWrapping, HalfFloatType, Matrix4, Vector2 } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\nimport {\r\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\r\n\tBVHShaderGLSL,\r\n} from 'three-mesh-bvh';\r\n\r\n// uniforms\r\nimport { PhysicalCameraUniform } from '../../uniforms/PhysicalCameraUniform.js';\r\nimport { EquirectHdrInfoUniform } from '../../uniforms/EquirectHdrInfoUniform.js';\r\nimport { LightsInfoUniformStruct } from '../../uniforms/LightsInfoUniformStruct.js';\r\nimport { AttributesTextureArray } from '../../uniforms/AttributesTextureArray.js';\r\nimport { MaterialsTexture, MATERIAL_PIXELS } from '../../uniforms/MaterialsTexture.js';\r\nimport { RenderTarget2DArray } from '../../uniforms/RenderTarget2DArray.js';\r\nimport { StratifiedSamplesTexture } from '../../uniforms/StratifiedSamplesTexture.js';\r\nimport { BlueNoiseTexture } from '../../textures/BlueNoiseTexture.js';\r\n\r\n// general glsl\r\nimport * as StructsGLSL from '../../shader/structs/index.js';\r\nimport * as SamplingGLSL from '../../shader/sampling/index.js';\r\nimport * as CommonGLSL from '../../shader/common/index.js';\r\nimport * as RandomGLSL from '../../shader/rand/index.js';\r\nimport * as BSDFGLSL from '../../shader/bsdf/index.js';\r\nimport * as PTBVHGLSL from '../../shader/bvh/index.js';\r\n\r\n// path tracer glsl\r\nimport * as RenderGLSL from './glsl/index.js';\r\n\r\nexport class PhysicalPathTracingMaterial extends MaterialBase {\r\n\r\n\tonBeforeRender() {\r\n\r\n\t\tthis.setDefine('FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1);\r\n\t\tthis.setDefine('FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0);\r\n\t\tthis.setDefine('FEATURE_FOG', this.materials.features.isUsed('FOG') ? 1 : 0);\r\n\r\n\t}\r\n\r\n\tconstructor(parameters) {\r\n\r\n\t\tsuper({\r\n\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthWrite: false,\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\tFEATURE_MIS: 1,\r\n\t\t\t\tFEATURE_RUSSIAN_ROULETTE: 1,\r\n\t\t\t\t// Match common runtime values to avoid recompilation on first render\r\n\t\t\t\tFEATURE_DOF: 0,\r\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\r\n\t\t\t\tFEATURE_FOG: 0,\r\n\r\n\t\t\t\t// 0 = PCG\r\n\t\t\t\t// 1 = Sobol\r\n\t\t\t\t// 2 = Stratified List\r\n\t\t\t\tRANDOM_TYPE: 2,\r\n\r\n\t\t\t\t// 0 = Perspective\r\n\t\t\t\t// 1 = Orthographic\r\n\t\t\t\t// 2 = Equirectangular\r\n\t\t\t\tCAMERA_TYPE: 0,\r\n\r\n\t\t\t\tDEBUG_MODE: 0,\r\n\r\n\t\t\t\tATTR_NORMAL: 0,\r\n\t\t\t\tATTR_TANGENT: 1,\r\n\t\t\t\tATTR_UV: 2,\r\n\t\t\t\tATTR_COLOR: 3,\r\n\t\t\t\tMATERIAL_PIXELS: MATERIAL_PIXELS,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\t// path trace uniforms\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\t\t\t\topacity: { value: 1 },\r\n\t\t\t\tbounces: { value: 10 },\r\n\t\t\t\ttransmissiveBounces: { value: 10 },\r\n\t\t\t\tfilterGlossyFactor: { value: 0 },\r\n\r\n\t\t\t\t// camera uniforms\r\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\r\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\r\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\r\n\r\n\t\t\t\t// scene uniforms\r\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\r\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\r\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\r\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\r\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\r\n\r\n\t\t\t\t// light uniforms\r\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\r\n\t\t\t\tiesProfiles: {\r\n\t\t\t\t\tvalue: new RenderTarget2DArray(360, 180, {\r\n\t\t\t\t\t\ttype: HalfFloatType,\r\n\t\t\t\t\t\twrapS: ClampToEdgeWrapping,\r\n\t\t\t\t\t\twrapT: ClampToEdgeWrapping,\r\n\t\t\t\t\t}).texture\r\n\t\t\t\t},\r\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\r\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\r\n\t\t\t\tenvironmentSaturation: { value: 1.0 },\r\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\r\n\r\n\t\t\t\t// background uniforms\r\n\t\t\t\tbackgroundBlur: { value: 0.0 },\r\n\t\t\t\tbackgroundMap: { value: null },\r\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\r\n\t\t\t\tbackgroundIntensity: { value: 1.0 },\r\n\t\t\t\tbackgroundRotation: { value: new Matrix4() },\r\n\t\t\t\tshadowCatcherReflectionIntensity: { value: 1.0 },\r\n\r\n\t\t\t\t// randomness uniforms\r\n\t\t\t\tseed: { value: 0 },\r\n\t\t\t\tsobolTexture: { value: null },\r\n\t\t\t\tstratifiedTexture: { value: new StratifiedSamplesTexture() },\r\n\t\t\t\tstratifiedOffsetTexture: { value: new BlueNoiseTexture(64, 1) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\r\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define RAY_OFFSET 1e-4\r\n\t\t\t\t#define INFINITY 1e20\r\n\r\n\t\t\t\tprecision highp isampler2D;\r\n\t\t\t\tprecision highp usampler2D;\r\n\t\t\t\tprecision highp sampler2DArray;\r\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\t// bvh intersection\r\n\t\t\t\t${BVHShaderGLSL.common_functions}\r\n\t\t\t\t${BVHShaderGLSL.bvh_struct_definitions}\r\n\t\t\t\t${BVHShaderGLSL.bvh_ray_functions}\r\n\r\n\t\t\t\t// uniform structs\r\n\t\t\t\t${StructsGLSL.camera_struct}\r\n\t\t\t\t${StructsGLSL.lights_struct}\r\n\t\t\t\t${StructsGLSL.equirect_struct}\r\n\t\t\t\t${StructsGLSL.material_struct}\r\n\t\t\t\t${StructsGLSL.surface_record_struct}\r\n\r\n\t\t\t\t// random\r\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\r\n\r\n\t\t\t\t\t${RandomGLSL.stratified_functions}\r\n\r\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\r\n\r\n\t\t\t\t\t${RandomGLSL.pcg_functions}\r\n\t\t\t\t\t${RandomGLSL.sobol_common}\r\n\t\t\t\t\t${RandomGLSL.sobol_functions}\r\n\r\n\t\t\t\t\t#define rand(v) sobol(v)\r\n\t\t\t\t\t#define rand2(v) sobol2(v)\r\n\t\t\t\t\t#define rand3(v) sobol3(v)\r\n\t\t\t\t\t#define rand4(v) sobol4(v)\r\n\r\n\t\t\t\t#else \t\t\t\t\t// PCG\r\n\r\n\t\t\t\t${RandomGLSL.pcg_functions}\r\n\r\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\r\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\r\n\t\t\t\t\tuint sobolPixelIndex = 0u;\r\n\t\t\t\t\tuint sobolPathIndex = 0u;\r\n\t\t\t\t\tuint sobolBounceIndex = 0u;\r\n\r\n\t\t\t\t\t#define rand(v) pcgRand()\r\n\t\t\t\t\t#define rand2(v) pcgRand2()\r\n\t\t\t\t\t#define rand3(v) pcgRand3()\r\n\t\t\t\t\t#define rand4(v) pcgRand4()\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// common\r\n\t\t\t\t${CommonGLSL.texture_sample_functions}\r\n\t\t\t\t${CommonGLSL.fresnel_functions}\r\n\t\t\t\t${CommonGLSL.util_functions}\r\n\t\t\t\t${CommonGLSL.math_functions}\r\n\t\t\t\t${CommonGLSL.shape_intersection_functions}\r\n\r\n\t\t\t\t// environment\r\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\r\n\t\t\t\tuniform mat4 environmentRotation;\r\n\t\t\t\tuniform float environmentIntensity;\r\n\t\t\t\tuniform float environmentSaturation;\r\n\r\n\t\t\t\tvec3 applyEnvSaturation( vec3 c ) {\r\n\r\n\t\t\t\t\tfloat g = dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\r\n\t\t\t\t\treturn mix( vec3( g ), c, environmentSaturation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// lighting\r\n\t\t\t\tuniform sampler2DArray iesProfiles;\r\n\t\t\t\tuniform LightsInfo lights;\r\n\r\n\t\t\t\t// background\r\n\t\t\t\tuniform float backgroundBlur;\r\n\t\t\t\tuniform float backgroundAlpha;\r\n\t\t\t\tuniform float shadowCatcherReflectionIntensity;\r\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\tuniform sampler2D backgroundMap;\r\n\t\t\t\tuniform mat4 backgroundRotation;\r\n\t\t\t\tuniform float backgroundIntensity;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// camera\r\n\t\t\t\tuniform mat4 cameraWorldMatrix;\r\n\t\t\t\tuniform mat4 invProjectionMatrix;\r\n\t\t\t\t#if FEATURE_DOF\r\n\r\n\t\t\t\tuniform PhysicalCamera physicalCamera;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// geometry\r\n\t\t\t\tuniform sampler2DArray attributesArray;\r\n\t\t\t\tuniform usampler2D materialIndexAttribute;\r\n\t\t\t\tuniform sampler2D materials;\r\n\t\t\t\tuniform sampler2DArray textures;\r\n\t\t\t\tuniform BVH bvh;\r\n\r\n\t\t\t\t// path tracer\r\n\t\t\t\tuniform int bounces;\r\n\t\t\t\tuniform int transmissiveBounces;\r\n\t\t\t\tuniform float filterGlossyFactor;\r\n\t\t\t\tuniform int seed;\r\n\r\n\t\t\t\t// image\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t// globals\r\n\t\t\t\tmat3 envRotation3x3;\r\n\t\t\t\tmat3 invEnvRotation3x3;\r\n\t\t\t\tfloat lightsDenom;\r\n\r\n\t\t\t\t// sampling\r\n\t\t\t\t${SamplingGLSL.shape_sampling_functions}\r\n\t\t\t\t${SamplingGLSL.equirect_functions}\r\n\t\t\t\t${SamplingGLSL.light_sampling_functions}\r\n\r\n\t\t\t\t${PTBVHGLSL.inside_fog_volume_function}\r\n\t\t\t\t${BSDFGLSL.ggx_functions}\r\n\t\t\t\t${BSDFGLSL.sheen_functions}\r\n\t\t\t\t${BSDFGLSL.iridescence_functions}\r\n\t\t\t\t${BSDFGLSL.fog_functions}\r\n\t\t\t\t${BSDFGLSL.bsdf_functions}\r\n\r\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\r\n\r\n\t\t\t\t\treturn clamp(\r\n\t\t\t\t\t\tmax(\r\n\t\t\t\t\t\t\troughness,\r\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\r\n\t\t\t\t\t\t0.0,\r\n\t\t\t\t\t\t1.0\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\r\n\r\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\r\n\r\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\r\n\t\t\t\t\treturn applyEnvSaturation( backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir ) );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\r\n\t\t\t\t\treturn applyEnvSaturation( environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir ) );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t${RenderGLSL.render_structs}\r\n\t\t\t\t${RenderGLSL.camera_util_functions}\r\n\t\t\t\t${RenderGLSL.trace_scene_function}\r\n\t\t\t\t${RenderGLSL.attenuate_hit_function}\r\n\t\t\t\t${RenderGLSL.direct_light_contribution_function}\r\n\t\t\t\t${RenderGLSL.get_surface_record_function}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t// init\r\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\r\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\r\n\t\t\t\t\tsobolPathIndex = uint( seed );\r\n\r\n\t\t\t\t\t// get camera ray\r\n\t\t\t\t\tRay ray = getCameraRay();\r\n\r\n\t\t\t\t\t// inverse environment rotation\r\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\r\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\r\n\t\t\t\t\tlightsDenom =\r\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\r\n\t\t\t\t\t\t\tfloat( lights.count ) :\r\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\r\n\r\n\t\t\t\t\t// final color\r\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\r\n\r\n\t\t\t\t\t// surface results\r\n\t\t\t\t\tSurfaceHit surfaceHit;\r\n\t\t\t\t\tScatterRecord scatterRec;\r\n\r\n\t\t\t\t\t// path tracing state\r\n\t\t\t\t\tRenderState state = initRenderState();\r\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\r\n\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\r\n\t\t\t\t\t\tray.origin, - ray.direction,\r\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\r\n\t\t\t\t\t\tstate.fogMaterial\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\r\n\r\n\t\t\t\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\t\t\t\tstate.depth ++;\r\n\t\t\t\t\t\tstate.traversals = bounces - i;\r\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\r\n\r\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\r\n\r\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\r\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\r\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\r\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\tLightRecord lightRec;\r\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\r\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\r\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\r\n\t\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the contribution\r\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\r\n\r\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\r\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\r\n\t\t\t\t\t\t\t\tvec3 envColor;\r\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\r\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\r\n\r\n\t\t\t\t\t\t\t\t// and weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * applyEnvSaturation( envColor ) * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\r\n\t\t\t\t\t\t\t\t\tapplyEnvSaturation( sampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) ) *\r\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\r\n\r\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\r\n\r\n\t\t\t\t\t\t\tstate.fogMaterial = material;\r\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// early out if this is a matte material\r\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\r\n\r\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\r\n\t\t\t\t\t\t// then skip it\r\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tSurfaceRecord surf;\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgetSurfaceRecord(\r\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\r\n\t\t\t\t\t\t\t\tsurf\r\n\t\t\t\t\t\t\t) == SKIP_SURFACE\r\n\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\r\n\t\t\t\t\t\t\t// crash the context with too long a loop.\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// shadow/reflection catcher: Production Grade V2\r\n\t\t\t\t\t\t// Solves wavering ripples (stable Fresnel), double ghosting (transmission mask), black circle (screen-blend alpha)\r\n\t\t\t\t\t\tif ( material.shadowReflectionCatcher && state.firstRay ) {\r\n\r\n\t\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, surf.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t\t// --- 1. STABLE FRESNEL MASK (prevents \"waver\" ripples) ---\r\n\t\t\t\t\t\t\t// Use perfect reflection vector so the mask does not jitter with roughness\r\n\t\t\t\t\t\t\tvec3 perfectReflDir = reflect( ray.direction, surf.faceNormal );\r\n\t\t\t\t\t\t\tvec3 stableHalfVector = normalize( - ray.direction + perfectReflDir );\r\n\t\t\t\t\t\t\tfloat stableDotVH = saturate( dot( - ray.direction, stableHalfVector ) );\r\n\t\t\t\t\t\t\tvec3 f0 = mix( vec3( surf.f0 * surf.specularIntensity ), surf.color, surf.metalness );\r\n\t\t\t\t\t\t\tvec3 transmissionMask = vec3( 1.0 ) - schlickFresnel( stableDotVH, f0 );\r\n\r\n\t\t\t\t\t\t\t// --- 2. REFLECTION TRACING (roughness-aware ray) ---\r\n\t\t\t\t\t\t\tScatterRecord catcherScatter = bsdfSample( - ray.direction, surf );\r\n\t\t\t\t\t\t\tvec3 reflectionWeight = vec3( 0.0 );\r\n\t\t\t\t\t\t\tif ( catcherScatter.pdf > 0.0 ) {\r\n\t\t\t\t\t\t\t\treflectionWeight = catcherScatter.color / catcherScatter.pdf;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( any( isnan( reflectionWeight ) ) || any( isinf( reflectionWeight ) ) ) {\r\n\t\t\t\t\t\t\t\treflectionWeight = vec3( 0.0 );\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvec3 reflDir = catcherScatter.direction;\r\n\t\t\t\t\t\t\tif ( dot( reflDir, surf.faceNormal ) < 0.0 ) {\r\n\t\t\t\t\t\t\t\treflDir = reflect( ray.direction, surf.faceNormal );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tRay reflRay;\r\n\t\t\t\t\t\t\treflRay.origin = stepRayOrigin( hitPoint, reflDir, surf.faceNormal, 0.0 );\r\n\t\t\t\t\t\t\treflRay.direction = reflDir;\r\n\r\n\t\t\t\t\t\t\tSurfaceHit reflHit;\r\n\t\t\t\t\t\t\tint reflHitType = traceScene( reflRay, state.fogMaterial, reflHit );\r\n\t\t\t\t\t\t\tvec3 reflectionColor = vec3( 0.0 );\r\n\r\n\t\t\t\t\t\t\tif ( reflHitType == SURFACE_HIT ) {\r\n\t\t\t\t\t\t\t\tuint reflMatIndex = uTexelFetch1D( materialIndexAttribute, reflHit.faceIndices.x ).r;\r\n\t\t\t\t\t\t\t\tMaterial reflMat = readMaterialInfo( materials, reflMatIndex );\r\n\t\t\t\t\t\t\t\tSurfaceRecord reflSurf;\r\n\t\t\t\t\t\t\t\tif ( getSurfaceRecord( reflMat, reflHit, attributesArray, 0.0, reflSurf ) != SKIP_SURFACE ) {\r\n\t\t\t\t\t\t\t\t\tvec3 reflHitPoint = stepRayOrigin( reflRay.origin, reflRay.direction, reflSurf.faceNormal, reflHit.dist );\r\n\t\t\t\t\t\t\t\t\treflectionColor = reflSurf.emission + directLightContribution( - reflDir, reflSurf, state, reflHitPoint );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// --- 3. SHADOW TRACING ---\r\n\t\t\t\t\t\t\tfloat shadowFactor = 0.0;\r\n\t\t\t\t\t\t\tstate.isShadowRay = true;\r\n\t\t\t\t\t\t\tif ( lightsDenom != 0.0 && rand( 9 ) < float( lights.count ) / lightsDenom ) {\r\n\t\t\t\t\t\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, hitPoint, rand3( 10 ) );\r\n\t\t\t\t\t\t\t\tif ( dot( surf.faceNormal, lightRec.direction ) >= 0.0 && lightRec.pdf > 0.0 ) {\r\n\t\t\t\t\t\t\t\t\tRay lightRay;\r\n\t\t\t\t\t\t\t\t\tlightRay.origin = hitPoint;\r\n\t\t\t\t\t\t\t\t\tlightRay.direction = lightRec.direction;\r\n\t\t\t\t\t\t\t\t\tvec3 att;\r\n\t\t\t\t\t\t\t\t\tif ( attenuateHit( state, lightRay, lightRec.dist, att ) ) shadowFactor = 1.0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\r\n\t\t\t\t\t\t\t\tvec3 envColor, envDirection;\r\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 11 ), envColor, envDirection );\r\n\t\t\t\t\t\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\r\n\t\t\t\t\t\t\t\tif ( dot( surf.faceNormal, envDirection ) >= 0.0 && envPdf > 0.0 ) {\r\n\t\t\t\t\t\t\t\t\tRay envRay;\r\n\t\t\t\t\t\t\t\t\tenvRay.origin = hitPoint;\r\n\t\t\t\t\t\t\t\t\tenvRay.direction = envDirection;\r\n\t\t\t\t\t\t\t\t\tvec3 att;\r\n\t\t\t\t\t\t\t\t\tif ( attenuateHit( state, envRay, INFINITY, att ) ) shadowFactor = 1.0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstate.isShadowRay = false;\r\n\r\n\t\t\t\t\t\t\t// --- 4. COMPOSITING (transmission masking: reflection hides shadow/background) ---\r\n\t\t\t\t\t\t\tvec3 backColor = sampleBackground( ray.direction, rand2( 2 ) );\r\n\t\t\t\t\t\t\tvec3 shadowedBackground = backColor * ( 1.0 - shadowFactor );\r\n\t\t\t\t\t\t\tvec3 finalReflection = reflectionColor * reflectionWeight * shadowCatcherReflectionIntensity;\r\n\t\t\t\t\t\t\tgl_FragColor.rgb = shadowedBackground * transmissionMask + finalReflection;\r\n\r\n\t\t\t\t\t\t\t// --- 5. ALPHA (screen blend to avoid black circle) ---\r\n\t\t\t\t\t\t\tfloat reflectionLuma = dot( finalReflection, vec3( 0.2126, 0.7152, 0.0722 ) );\r\n\t\t\t\t\t\t\tfloat reflAlpha = saturate( reflectionLuma * 1.5 );\r\n\t\t\t\t\t\t\tfloat shadowAlpha = shadowFactor * opacity;\r\n\t\t\t\t\t\t\tshadowAlpha *= ( 1.0 - reflAlpha );\r\n\t\t\t\t\t\t\tfloat combinedAlpha = 1.0 - ( 1.0 - shadowAlpha ) * ( 1.0 - reflAlpha );\r\n\t\t\t\t\t\t\tgl_FragColor.a = max( backgroundAlpha, combinedAlpha );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\r\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\r\n\r\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\r\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t// next event estimation\r\n\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\r\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\r\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\r\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\r\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// accumulate emissive color\r\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\r\n\r\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\r\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\r\n\t\t\t\t\t\t// perform this separate from a bounce\r\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\r\n\t\t\t\t\t\t\ti --;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// handle throughput color transformation\r\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\r\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\r\n\r\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\r\n\r\n\t\t\t\t\t\t// russian roulette path termination\r\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\r\n\t\t\t\t\t\tuint minBounces = 3u;\r\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\r\n\r\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\r\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\r\n\t\t\t\t\t\trrProb = sqrt( rrProb );\r\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\r\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\r\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\r\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\r\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\r\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// prepare for next ray\r\n\t\t\t\t\t\tray.direction = scatterRec.direction;\r\n\t\t\t\t\t\tray.origin = hitPoint;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t\t#if DEBUG_MODE == 1\r\n\r\n\t\t\t\t\t// output the number of rays checked in the path and number of\r\n\t\t\t\t\t// transmissive rays encountered.\r\n\t\t\t\t\tgl_FragColor.rgb = vec3(\r\n\t\t\t\t\t\tfloat( state.depth ),\r\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\r\n\t\t\t\t\t\t0.0\r\n\t\t\t\t\t);\r\n\t\t\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\r\n\r\n\t\t});\r\n\r\n\t\tthis.setValues(parameters);\r\n\r\n\t}\r\n\r\n}","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending, Vector4, NearestFilter } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { BlendMaterial } from '../materials/fullscreen/BlendMaterial.js';\r\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\r\nimport { PhysicalPathTracingMaterial } from '../materials/pathtracing/PhysicalPathTracingMaterial.js';\r\n\r\nfunction* renderTask() {\r\n\r\n\tconst {\r\n\t\t_renderer,\r\n\t\t_fsQuad,\r\n\t\t_blendQuad,\r\n\t\t_primaryTarget,\r\n\t\t_blendTargets,\r\n\t\t_sobolTarget,\r\n\t\t_subframe,\r\n\t\talpha,\r\n\t\tmaterial,\r\n\t} = this;\r\n\tconst _ogScissor = new Vector4();\r\n\tconst _ogViewport = new Vector4();\r\n\r\n\tconst blendMaterial = _blendQuad.material;\r\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\tblendMaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NoBlending;\r\n\t\t\tmaterial.opacity = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NormalBlending;\r\n\r\n\t\t}\r\n\r\n\t\tconst [ subX, subY, subW, subH ] = _subframe;\r\n\r\n\t\tconst w = _primaryTarget.width;\r\n\t\tconst h = _primaryTarget.height;\r\n\t\tmaterial.resolution.set( w * subW, h * subH );\r\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\r\n\t\tmaterial.stratifiedTexture.init( 20, material.bounces + material.transmissiveBounces + 5 );\r\n\t\tmaterial.stratifiedTexture.next();\r\n\t\tmaterial.seed ++;\r\n\r\n\t\tconst tilesX = this.tiles.x || 1;\r\n\t\tconst tilesY = this.tiles.y || 1;\r\n\t\tconst totalTiles = tilesX * tilesY;\r\n\r\n\t\tconst pxSubW = Math.ceil( w * subW );\r\n\t\tconst pxSubH = Math.ceil( h * subH );\r\n\t\tconst pxSubX = Math.floor( subX * w );\r\n\t\tconst pxSubY = Math.floor( subY * h );\r\n\r\n\t\tconst pxTileW = Math.ceil( pxSubW / tilesX );\r\n\t\tconst pxTileH = Math.ceil( pxSubH / tilesY );\r\n\r\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\r\n\r\n\t\t\t\t// store og state\r\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\r\n\t\t\t\tconst ogScissorTest = _renderer.getScissorTest();\r\n\t\t\t\t_renderer.getScissor( _ogScissor );\r\n\t\t\t\t_renderer.getViewport( _ogViewport );\r\n\r\n\t\t\t\tlet tx = x;\r\n\t\t\t\tlet ty = y;\r\n\t\t\t\tif ( ! this.stableTiles ) {\r\n\r\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\r\n\t\t\t\t\ttx = tileIndex % tilesX;\r\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\r\n\r\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// set the scissor and the viewport on the render target\r\n\t\t\t\t// note that when using the webgl renderer set viewport the device pixel ratio\r\n\t\t\t\t// is multiplied into the field causing some pixels to not be rendered\r\n\t\t\t\tconst reverseTy = tilesY - ty - 1;\r\n\t\t\t\t_primaryTarget.scissor.set(\r\n\t\t\t\t\tpxSubX + tx * pxTileW,\r\n\t\t\t\t\tpxSubY + reverseTy * pxTileH,\r\n\t\t\t\t\tMath.min( pxTileW, pxSubW - tx * pxTileW ),\r\n\t\t\t\t\tMath.min( pxTileH, pxSubH - reverseTy * pxTileH ),\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_primaryTarget.viewport.set(\r\n\t\t\t\t\tpxSubX,\r\n\t\t\t\t\tpxSubY,\r\n\t\t\t\t\tpxSubW,\r\n\t\t\t\t\tpxSubH,\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\r\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t\t\t_renderer.setScissorTest( true );\r\n\r\n\t\t\t\t_renderer.autoClear = false;\r\n\t\t\t\t_fsQuad.render( _renderer );\r\n\r\n\t\t\t\t// reset original renderer state\r\n\t\t\t\t_renderer.setViewport( _ogViewport );\r\n\t\t\t\t_renderer.setScissor( _ogScissor );\r\n\t\t\t\t_renderer.setScissorTest( ogScissorTest );\r\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\t\t\t\t_renderer.autoClear = ogAutoClear;\r\n\r\n\t\t\t\t// swap and blend alpha targets\r\n\t\t\t\tif ( alpha ) {\r\n\r\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\r\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\r\n\r\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\r\n\t\t\t\t\t_blendQuad.render( _renderer );\r\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.samples += ( 1 / totalTiles );\r\n\r\n\t\t\t\t// round the samples value if we've finished the tiles\r\n\t\t\t\tif ( x === tilesX - 1 && y === tilesY - 1 ) {\r\n\r\n\t\t\t\t\tthis.samples = Math.round( this.samples );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tyield;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst ogClearColor = new Color();\r\nexport class PathTracingRenderer {\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._fsQuad.material;\r\n\r\n\t}\r\n\r\n\tset material( v ) {\r\n\r\n\t\tthis._fsQuad.material.removeEventListener( 'recompilation', this._compileFunction );\r\n\t\tv.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t\tthis._fsQuad.material = v;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\r\n\r\n\t}\r\n\r\n\tset alpha( v ) {\r\n\r\n\t\tif ( this._alpha === v ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! v ) {\r\n\r\n\t\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\t\tthis._blendTargets[ 1 ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis._alpha = v;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tget alpha() {\r\n\r\n\t\treturn this._alpha;\r\n\r\n\t}\r\n\r\n\tget isCompiling() {\r\n\r\n\t\treturn Boolean( this._compilePromise );\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.camera = null;\r\n\t\tthis.tiles = new Vector2( 3, 3 );\r\n\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.stableTiles = true;\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._subframe = new Vector4( 0, 0, 1, 1 );\r\n\t\tthis._opacityFactor = 1.0;\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._alpha = false;\r\n\t\tthis._fsQuad = new FullScreenQuad( new PhysicalPathTracingMaterial() );\r\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\r\n\t\tthis._task = null;\r\n\t\tthis._currentTile = 0;\r\n\t\tthis._compilePromise = null;\r\n\r\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\r\n\r\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t} );\r\n\t\tthis._blendTargets = [\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t];\r\n\r\n\t\t// Debounced compile: wait one frame so multiple define/param changes in one burst cause a single compile.\r\n\t\t// Reduces GPU exhaustion when toggling options or loading scenes.\r\n\t\tthis._compileScheduled = false;\r\n\t\tthis._compileFunction = () => {\r\n\r\n\t\t\tif ( this._compileScheduled ) return;\r\n\t\t\tthis._compileScheduled = true;\r\n\r\n\t\t\tconst self = this;\r\n\t\t\trequestAnimationFrame( function doCompile() {\r\n\r\n\t\t\t\tself._compileScheduled = false;\r\n\t\t\t\tconst promise = self.compileMaterial( self._fsQuad._mesh );\r\n\t\t\t\tpromise.then( () => {\r\n\r\n\t\t\t\t\tif ( self._compilePromise === promise ) {\r\n\r\n\t\t\t\t\t\tself._compilePromise = null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tself._compilePromise = promise;\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t\tthis.material.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t}\r\n\r\n\tcompileMaterial() {\r\n\r\n\t\treturn this._renderer.compileAsync( this._fsQuad._mesh );\r\n\r\n\t}\r\n\r\n\tsetCamera( camera ) {\r\n\r\n\t\tconst { material } = this;\r\n\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\r\n\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\r\n\t\tmaterial.physicalCamera.updateFrom( camera );\r\n\r\n\t\t// Perspective camera (default)\r\n\t\tlet cameraType = 0;\r\n\r\n\t\t// An orthographic projection matrix will always have the bottom right element == 1\r\n\t\t// And a perspective projection matrix will always have the bottom right element == 0\r\n\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\r\n\r\n\t\t\t// Orthographic\r\n\t\t\tcameraType = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( camera.isEquirectCamera ) {\r\n\r\n\t\t\t// Equirectangular\r\n\t\t\tcameraType = 2;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\r\n\r\n\t\tthis.camera = camera;\r\n\r\n\t}\r\n\r\n\tsetSize( w, h ) {\r\n\r\n\t\tw = Math.ceil( w );\r\n\t\th = Math.ceil( h );\r\n\r\n\t\tif ( this._primaryTarget.width === w && this._primaryTarget.height === h ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis._primaryTarget.setSize( w, h );\r\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\r\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tgetSize( target ) {\r\n\r\n\t\ttarget.x = this._primaryTarget.width;\r\n\t\ttarget.y = this._primaryTarget.height;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._primaryTarget.dispose();\r\n\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\tthis._blendTargets[ 1 ].dispose();\r\n\t\tthis._sobolTarget.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\t\tthis._blendQuad.dispose();\r\n\t\tthis._task = null;\r\n\t\tthis._compilePromise = null;\r\n\t\tthis._compileScheduled = false;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\r\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.getClearColor( ogClearColor );\r\n\r\n\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\r\n\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._task = null;\r\n\r\n\t\tthis.material.stratifiedTexture.stableNoise = this.stableNoise;\r\n\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\tthis.material.seed = 0;\r\n\t\t\tthis.material.stratifiedTexture.reset();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\t// ensure we've updated our defines before rendering so we can ensure we\r\n\t\t// can wait for compilation to finish\r\n\t\tthis.material.onBeforeRender();\r\n\t\tif ( this.isCompiling ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this._task ) {\r\n\r\n\t\t\tthis._task = renderTask.call( this );\r\n\r\n\t\t}\r\n\r\n\t\tthis._task.next();\r\n\r\n\t}\r\n\r\n}\r\n"],"names":["camera_struct","equirect_struct","lights_struct","surface_record_struct","equirect_functions","light_sampling_functions","generateSobolFunctionVariants","dim","type","generateSobolSampleFunctions","utype","vtype","num","components","combineValues","sobol_common","sobol_point_generation","sobol_functions","stratified_functions","BlendMaterial","MaterialBase","parameters","NoBlending","SobolNumbersMaterial","Vector2","SobolNumberMapGenerator","renderer","dimensions","target","WebGLRenderTarget","FloatType","RGBAFormat","NearestFilter","ogTarget","quad","FullScreenQuad","PhysicalCamera","PerspectiveCamera","size","args","source","recursive","PhysicalCameraUniform","camera","toHalfFloatArray","f32Array","f16Array","i","n","DataUtils","binarySearchFindClosestIndexOf","array","targetValue","offset","count","lower","upper","mid","colorToLuminance","r","g","b","preprocessEnvMap","envMap","targetType","HalfFloatType","map","Source","width","height","data","originalStride","newData","targetStride","maxIntValue","MAX_HALF_FLOAT","l","v","ogData","y","x","newY","ogIndex","newIndex","c","EquirectHdrInfoUniform","blackTex","DataTexture","LinearFilter","RepeatWrapping","marginalWeights","RedFormat","conditionalWeights","hdr","ClampToEdgeWrapping","stride","pdfConditional","cdfConditional","pdfMarginal","cdfMarginal","totalSumValue","cumulativeWeightMarginal","cumulativeRowWeight","weight","marginalDataArray","conditionalDataArray","dist","row","col","LIGHT_PIXELS","RECT_AREA_LIGHT","CIRC_AREA_LIGHT","SPOT_LIGHT","DIR_LIGHT","POINT_LIGHT","u","Vector3","m","Matrix4","worldQuaternion","Quaternion","eye","up","LightsInfoUniformStruct","tex","lights","iesTextures","pixelCount","dimension","floatArray","baseIndex","index","p","radius","worldPosition","targetPosition","hash","bufferToHash","copyArrayToArray","fromArray","fromStride","toArray","toStride","bpe","maxValue","i4","is","j","FloatAttributeTextureArray","DataArrayTexture","attr","baseImage","image","itemSize","attrs","itemCount","attrsLength","textures","FloatVertexAttributeTexture","AttributesTextureArray","normal","tangent","uv","color","prevColor","Color","getTextureHash","texture","assignOptions","options","key","RenderTarget2DArray","WebGLArrayRenderTarget","textureOptions","fsQuad","CopyMaterial","prevRenderTarget","prevToneMapping","prevAlpha","depth","NoToneMapping","hashes","updated","ShaderMaterial","shuffle","arr","random","StratifiedSampler","strataCount","strata","samples","stratum","StratifiedSamplerCombined","listOfDimensions","totalDim","combined","strataObjs","sampler","RandomGenerator","seed","StratifiedSamplesTexture","shuffleArray","replaceIndex","tmp","fillWithOnes","BlueNoiseSamples","score","binaryPattern","currValue","currIndex","pScore","sigma","lookupWidth","lookupTable","sigma2","dist2","multiplier","px","py","lookupIndex","value","sx","sy","sindex","BlueNoiseGenerator","savedSamples","majorityPointsRatio","pointCount","initialSamples","clusterIndex","voidIndex","ditherArray","rank","totalSize","getStride","channels","getFormat","RGFormat","BlueNoiseTexture","generator","format","result","bin","l2","fresnel_functions","shape_intersection_functions","texture_sample_functions","bsdf_functions","fog_functions","iridescence_functions","sheen_functions","inside_fog_volume_function","attenuate_hit_function","camera_util_functions","direct_light_contribution_function","get_surface_record_function","render_structs","trace_scene_function","PhysicalPathTracingMaterial","MATERIAL_PIXELS","MeshBVHUniformStruct","UIntVertexAttributeTexture","MaterialsTexture","BVHShaderGLSL.common_functions","BVHShaderGLSL.bvh_struct_definitions","BVHShaderGLSL.bvh_ray_functions","StructsGLSL.camera_struct","StructsGLSL.lights_struct","StructsGLSL.equirect_struct","StructsGLSL.material_struct","StructsGLSL.surface_record_struct","RandomGLSL.stratified_functions","RandomGLSL.pcg_functions","RandomGLSL.sobol_common","RandomGLSL.sobol_functions","CommonGLSL.texture_sample_functions","CommonGLSL.fresnel_functions","CommonGLSL.util_functions","CommonGLSL.math_functions","CommonGLSL.shape_intersection_functions","SamplingGLSL.shape_sampling_functions","SamplingGLSL.equirect_functions","SamplingGLSL.light_sampling_functions","PTBVHGLSL.inside_fog_volume_function","BSDFGLSL.ggx_functions","BSDFGLSL.sheen_functions","BSDFGLSL.iridescence_functions","BSDFGLSL.fog_functions","BSDFGLSL.bsdf_functions","RenderGLSL.render_structs","RenderGLSL.camera_util_functions","RenderGLSL.trace_scene_function","RenderGLSL.attenuate_hit_function","RenderGLSL.direct_light_contribution_function","RenderGLSL.get_surface_record_function","renderTask","_renderer","_fsQuad","_blendQuad","_primaryTarget","_blendTargets","_sobolTarget","_subframe","alpha","material","_ogScissor","Vector4","_ogViewport","blendMaterial","blendTarget1","blendTarget2","NormalBlending","subX","subY","subW","subH","w","h","tilesX","tilesY","totalTiles","pxSubW","pxSubH","pxSubX","pxSubY","pxTileW","pxTileH","ogRenderTarget","ogAutoClear","ogScissorTest","tx","ty","tileIndex","reverseTy","ogClearColor","PathTracingRenderer","self","promise","cameraType","ogClearAlpha"],"mappings":"8cAAO,MAAMA,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA1BC,GAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA5BC,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA1BC,GAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAlCC,GAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA9BC,GAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCzCC,GAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECUpCC,GAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECX3BC,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA1BC,GAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAlCC,GAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA5BC,GAAuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAvCC,GAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAnCC,GAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAlCC,GAA6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECC7CC,GAAwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECDxCC,GAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA3BC,GAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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"}