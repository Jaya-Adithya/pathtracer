{"version":3,"file":"pcg.glsl-D_3-p9wz.js","sources":["../../node_modules/three/examples/jsm/postprocessing/Pass.js","../../node_modules/three-mesh-bvh/src/core/Constants.js","../../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../../node_modules/three-mesh-bvh/src/core/BVHNode.js","../../node_modules/three-mesh-bvh/src/core/build/sortUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../../node_modules/three-mesh-bvh/src/core/BVH.js","../../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../../node_modules/three-mesh-bvh/src/core/GeometryBVH.js","../../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../../node_modules/three-mesh-bvh/src/webgl/VertexAttributeTexture.js","../../node_modules/three-mesh-bvh/src/webgl/MeshBVHUniformStruct.js","../../node_modules/three-mesh-bvh/src/webgl/glsl/common_functions.glsl.js","../../node_modules/three-mesh-bvh/src/webgl/glsl/bvh_ray_functions.glsl.js","../../node_modules/three-mesh-bvh/src/webgl/glsl/bvh_struct_definitions.glsl.js","../../src/core/utils/BufferAttributeUtils.js","../../src/core/utils/mergeGeometries.js","../../src/core/utils/GeometryPreparationUtils.js","../../src/utils/bufferToHash.js","../../src/core/utils/MeshDiff.js","../../src/core/utils/convertToStaticGeometry.js","../../src/core/utils/BakedGeometry.js","../../src/core/utils/StaticGeometryGenerator.js","../../src/core/PathTracingSceneGenerator.js","../../src/core/utils/sceneUpdateUtils.js","../../src/uniforms/MaterialsTexture.js","../../src/shader/structs/material_struct.glsl.js","../../src/shader/sampling/shape_sampling_functions.glsl.js","../../src/shader/rand/pcg.glsl.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\n/**\n * Abstract base class for all post processing passes.\n *\n * This module is only relevant for post processing with {@link WebGLRenderer}.\n *\n * @abstract\n * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';\n */\nclass Pass {\n\n\t/**\n\t * Constructs a new pass.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPass = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass is processed by the composer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass indicates to swap read and write buffer after rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.needsSwap = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass clears its buffer before rendering\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clear = false;\n\n\t\t/**\n\t\t * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers\n\t\t * pass chain gets automatically rendered to screen, no matter how this property is configured.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @abstract\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( /* width, height */ ) {}\n\n\t/**\n\t * This method holds the render logic of a pass. It must be implemented in all derived classes.\n\t *\n\t * @abstract\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single full screen quad for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Mesh\n * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';\n */\nclass FullScreenQuad {\n\n\t/**\n\t * Constructs a new full screen quad.\n\t *\n\t * @param {?Material} material - The material to render te full screen quad with.\n\t */\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\t/**\n\t * Renders the full screen quad.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\t/**\n\t * The quad's material.\n\t *\n\t * @type {?Material}\n\t */\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a primitive intersection vs traversing\n// bounds.\n// TODO: could be tuned per primitive type (triangles vs lines vs points)\nexport const PRIMITIVE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const UINT32_PER_NODE = BYTES_PER_NODE / 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// Bit masks for 32 bit node data\nexport const LEAFNODE_MASK_32 = IS_LEAFNODE_FLAG << 16;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafSize: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null,\n\t[ SKIP_GENERATION ]: false,\n};\n\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided primitive bounds\nexport function expandByPrimitiveBounds( startIndex, primitiveBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = primitiveBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = primitiveBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { IS_LEAFNODE_FLAG, UINT32_PER_NODE } from '../Constants.js';\n\nexport function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === IS_LEAFNODE_FLAG;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\n// Returns the uint32-aligned offset of the left child node for performance\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + UINT32_PER_NODE;\n\n}\n\n// Returns the uint32-aligned offset of the right child node for performance\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\t// stored value is relative offset from parent, convert to absolute uint32 index\n\tconst relativeOffset = uint32Array[ n32 + 6 ];\n\treturn n32 + relativeOffset * UINT32_PER_NODE;\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","// computes the union of the bounds of all of the given primitives and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the primitives, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( primitiveBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\tfor ( let i = ( offset - boundsOffset ) * 6, end = ( offset + count - boundsOffset ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = primitiveBounds[ i + 0 ];\n\t\tconst hx = primitiveBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = primitiveBounds[ i + 2 ];\n\t\tconst hy = primitiveBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = primitiveBounds[ i + 4 ];\n\t\tconst hz = primitiveBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByPrimitiveBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, PRIMITIVE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = /* @__PURE__ */ new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = /* @__PURE__ */ new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, primitiveBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( primitiveBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = PRIMITIVE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst boundsOffset = primitiveBounds.offset || 0;\n\t\tconst cStart = ( offset - boundsOffset ) * 6;\n\t\tconst cEnd = ( offset + count - boundsOffset ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer primitives than we're planning to split then just check all\n\t\t\t// the primitive positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each primitive and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no primitives\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `BVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of all the provided primitives\nfunction getAverage( primitiveBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tconst boundsOffset = primitiveBounds.offset;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += primitiveBounds[ ( i - boundsOffset ) * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class BVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","// reorders the partition buffer such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nexport function partition( buffer, stride, primitiveBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && primitiveBounds[ ( left - boundsOffset ) * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a primitive center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && primitiveBounds[ ( right - boundsOffset ) * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the primitives at index\n\t\t\t// left and right; that's the elements in the partition buffer and the bounds\n\t\t\tfor ( let i = 0; i < stride; i ++ ) {\n\n\t\t\t\tlet t0 = buffer[ left * stride + i ];\n\t\t\t\tbuffer[ left * stride + i ] = buffer[ right * stride + i ];\n\t\t\t\tbuffer[ right * stride + i ] = t0;\n\n\t\t\t}\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst l = left - boundsOffset;\n\t\t\t\tconst r = right - boundsOffset;\n\t\t\t\tconst tb = primitiveBounds[ l * 6 + i ];\n\t\t\t\tprimitiveBounds[ l * 6 + i ] = primitiveBounds[ r * 6 + i ];\n\t\t\t\tprimitiveBounds[ r * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst node32Index = byteOffset / 4;\n\tconst node16Index = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ node32Index + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tuint8Array.set( new Uint8Array( node.buffer ), byteOffset );\n\t\t\treturn byteOffset + node.buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tuint32Array[ node32Index + 6 ] = node.offset;\n\t\t\tuint16Array[ node16Index + 14 ] = node.count;\n\t\t\tuint16Array[ node16Index + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst { left, right, splitAxis } = node;\n\n\t\t// fill in the left node contents\n\t\tconst leftByteOffset = byteOffset + BYTES_PER_NODE;\n\t\tlet rightByteOffset = _populateBuffer( leftByteOffset, left );\n\n\t\t// calculate relative offset from parent to right child\n\t\tconst currentNodeIndex = byteOffset / BYTES_PER_NODE;\n\t\tconst rightNodeIndex = rightByteOffset / BYTES_PER_NODE;\n\t\tconst relativeRightIndex = rightNodeIndex - currentNodeIndex;\n\n\t\t// check if the relative offset is too high\n\t\tif ( relativeRightIndex > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store relative child node offset greater than 32 bits.' );\n\n\t\t}\n\n\t\t// fill in the right node contents (store as relative offset)\n\t\tuint32Array[ node32Index + 6 ] = relativeRightIndex;\n\t\tuint32Array[ node32Index + 7 ] = splitAxis;\n\n\t\t// return the next available buffer pointer\n\t\treturn _populateBuffer( rightByteOffset, right );\n\n\t}\n\n}\n","import { getBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { BVHNode } from '../BVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function buildTree( bvh, primitiveBounds, offset, count, options ) {\n\n\t// expand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafSize,\n\t\tstrategy,\n\t\tonProgress,\n\t} = options;\n\n\tconst partitionBuffer = bvh.primitiveBuffer;\n\tconst partitionStride = bvh.primitiveBufferStride;\n\n\t// generate intermediate variables\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new BVHNode();\n\tgetBounds( primitiveBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( primitivesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( primitivesProcessed / count );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its primitives and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `BVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafSize || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, primitiveBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( partitionBuffer, partitionStride, primitiveBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new BVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( primitiveBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new BVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( primitiveBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\t// get the range of buffer data to construct / arrange\n\tconst rootRanges = bvh.getRootRanges( options.range );\n\tconst firstRange = rootRanges[ 0 ];\n\tconst lastRange = rootRanges[ rootRanges.length - 1 ];\n\tconst fullRange = {\n\t\toffset: firstRange.offset,\n\t\tcount: lastRange.offset + lastRange.count - firstRange.offset,\n\t};\n\n\t// construct the primitive bounds for sorting\n\tconst primitiveBounds = new Float32Array( 6 * fullRange.count );\n\tprimitiveBounds.offset = fullRange.offset;\n\tbvh.computePrimitiveBounds( fullRange.offset, fullRange.count, primitiveBounds );\n\n\t// Build BVH roots\n\tbvh._roots = rootRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, primitiveBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = /* @__PURE__ */ new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED, UINT32_PER_NODE } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexOffset + nodeIndex32 / UINT32_PER_NODE, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getFullPrimitiveRange( geo, range, stride ) {\n\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / stride;\n\tconst end = ( drawRange.start + drawRange.count ) / stride;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( primitiveCount, end ) - offset;\n\treturn {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t};\n\n}\n\nfunction getPrimitiveGroupRanges( geo, stride ) {\n\n\treturn geo.groups.map( group => ( {\n\t\toffset: group.start / stride,\n\t\tcount: group.count / stride,\n\t} ));\n\n}\n\n// Function that extracts a set of mutually exclusive ranges representing the primitives being\n// drawn as determined by the geometry groups, draw range, and user specified range\nexport function getRootPrimitiveRanges( geo, range, stride ) {\n\n\tconst drawRange = getFullPrimitiveRange( geo, range, stride );\n\tconst primitiveRanges = getPrimitiveGroupRanges( geo, stride );\n\tif ( ! primitiveRanges.length ) {\n\n\t\treturn [ drawRange ];\n\n\t}\n\n\tconst ranges = [];\n\tconst drawRangeStart = drawRange.offset;\n\tconst drawRangeEnd = drawRange.offset + drawRange.count;\n\n\t// Create events for group boundaries\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst events = [];\n\tfor ( const group of primitiveRanges ) {\n\n\t\t// Account for cases where group size is set to Infinity\n\t\tconst { offset, count } = group;\n\t\tconst groupStart = offset;\n\t\tconst groupCount = isFinite( count ) ? count : ( primitiveCount - offset );\n\t\tconst groupEnd = ( offset + groupCount );\n\n\t\t// Only add events if the group intersects with the draw range\n\t\tif ( groupStart < drawRangeEnd && groupEnd > drawRangeStart ) {\n\n\t\t\tevents.push( { pos: Math.max( drawRangeStart, groupStart ), isStart: true } );\n\t\t\tevents.push( { pos: Math.min( drawRangeEnd, groupEnd ), isStart: false } );\n\n\t\t}\n\n\t}\n\n\t// Sort events by position, with 'end' events before 'start' events at the same position\n\tevents.sort( ( a, b ) => {\n\n\t\tif ( a.pos !== b.pos ) {\n\n\t\t\treturn a.pos - b.pos;\n\n\t\t} else {\n\n\t\t\treturn a.type === 'end' ? - 1 : 1;\n\n\t\t}\n\n\t} );\n\n\t// sweep through events and create ranges where activeGroups > 0\n\tlet activeGroups = 0;\n\tlet lastPos = null;\n\tfor ( const event of events ) {\n\n\t\tconst newPos = event.pos;\n\t\tif ( activeGroups !== 0 && newPos !== lastPos ) {\n\n\t\t\tranges.push( {\n\t\t\t\toffset: lastPos,\n\t\t\t\tcount: newPos - lastPos,\n\t\t\t} );\n\n\t\t}\n\n\t\tactiveGroups += event.isStart ? 1 : - 1;\n\t\tlastPos = newPos;\n\n\t}\n\n\treturn ranges;\n\n}\n","import { Box3 } from 'three';\nimport { BYTES_PER_NODE, UINT32_PER_NODE, DEFAULT_OPTIONS } from './Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, LEFT_NODE, RIGHT_NODE, SPLIT_AXIS } from './utils/nodeBufferUtils.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { shapecast as shapecastFunc } from './cast/shapecast.js';\nimport { getRootPrimitiveRanges } from './build/geometryUtils.js';\n\nconst tempBox = /* @__PURE__ */ new Box3();\n\nexport class BVH {\n\n\tconstructor() {\n\n\t\tthis._roots = null;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\n\t}\n\n\tinit( options ) {\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\tbuildPackedTree( this, options );\n\n\t}\n\n\tgetRootRanges( range ) {\n\n\t\t// TODO: can we avoid passing options in here\n\t\treturn getRootPrimitiveRanges( this.geometry, range, this.primitiveStride );\n\n\t}\n\n\traycastObject3D( /* object, raycaster, intersects = [] */ ) {\n\n\t\tthrow new Error( 'BVH: raycastObject3D() not implemented' );\n\n\t}\n\n\tshiftPrimitiveOffsets( offset ) {\n\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tif ( indirectBuffer ) {\n\n\t\t\t// the offsets are embedded in the indirect buffer\n\t\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\t\tindirectBuffer[ i ] += offset;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// offsets are embedded in the leaf nodes\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\t\t\t\tconst totalNodes = root.byteLength / BYTES_PER_NODE;\n\t\t\t\tfor ( let node = 0; node < totalNodes; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// offset value\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] += offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = IS_LEAF( node16Index, uint16Array );\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\tconst left = LEFT_NODE( node32Index );\n\t\t\t\tconst right = RIGHT_NODE( node32Index, uint32Array );\n\t\t\t\tconst splitAxis = SPLIT_AXIS( node32Index, uint32Array );\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n\t// Base shapecast implementation that can be used by subclasses\n\t// TODO: see if we can get rid of \"iterateFunc\" here as well as the primitive so the function\n\t// API aligns with the \"shapecast\" implementation\n\tshapecast( callbacks ) {\n\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsPrimitive,\n\t\t\tscratchPrimitive,\n\t\t\titerate,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsPrimitive ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsPrimitive ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet nodeOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecastFunc( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeOffset += root.byteLength / BYTES_PER_NODE;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = /* @__PURE__ */ new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = /* @__PURE__ */ new Vector3();\n\tconst dir2 = /* @__PURE__ */ new Vector3();\n\tconst v02 = /* @__PURE__ */ new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = /* @__PURE__ */ new Vector2();\n\tconst temp1 = /* @__PURE__ */ new Vector3();\n\tconst temp2 = /* @__PURE__ */ new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = /* @__PURE__ */ new Vector3();\n\tconst projectedPointTemp = /* @__PURE__ */ new Vector3();\n\tconst planeTemp = /* @__PURE__ */ new Plane();\n\tconst lineTemp = /* @__PURE__ */ new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Vector2, Line3, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst componentKeys = [ 'x', 'y', 'z' ];\nconst ZERO_EPSILON = 1e-15;\nconst ZERO_EPSILON_SQR = ZERO_EPSILON * ZERO_EPSILON;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.plane = new Plane();\n\t\tthis.isDegenerateIntoSegment = false;\n\t\tthis.isDegenerateIntoPoint = false;\n\t\tthis.degenerateSegment = new Line3();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tconst lengthAB = axis1.length();\n\t\tconst lengthBC = axis2.length();\n\t\tconst lengthCA = axis3.length();\n\n\t\tthis.isDegenerateIntoPoint = false;\n\t\tthis.isDegenerateIntoSegment = false;\n\n\t\tif ( lengthAB < ZERO_EPSILON ) {\n\n\t\t\tif ( lengthBC < ZERO_EPSILON || lengthCA < ZERO_EPSILON ) {\n\n\t\t\t\tthis.isDegenerateIntoPoint = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\t\tthis.degenerateSegment.start.copy( a );\n\t\t\t\tthis.degenerateSegment.end.copy( c );\n\n\t\t\t}\n\n\t\t} else if ( lengthBC < ZERO_EPSILON ) {\n\n\t\t\tif ( lengthCA < ZERO_EPSILON ) {\n\n\t\t\t\tthis.isDegenerateIntoPoint = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\t\tthis.degenerateSegment.start.copy( b );\n\t\t\t\tthis.degenerateSegment.end.copy( a );\n\n\t\t\t}\n\n\t\t} else if ( lengthCA < ZERO_EPSILON ) {\n\n\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\tthis.degenerateSegment.start.copy( c );\n\t\t\tthis.degenerateSegment.end.copy( b );\n\n\t\t}\n\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\tconst edge = /* @__PURE__ */ new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst cachedSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst tmpVec = /* @__PURE__ */ new Vector3();\n\tconst dir1 = /* @__PURE__ */ new Vector3();\n\tconst dir2 = /* @__PURE__ */ new Vector3();\n\tconst tempDir = /* @__PURE__ */ new Vector3();\n\tconst edge1 = /* @__PURE__ */ new Line3();\n\tconst edge2 = /* @__PURE__ */ new Line3();\n\tconst tempPoint = /* @__PURE__ */ new Vector3();\n\tconst bounds1 = /* @__PURE__ */ new Vector2();\n\tconst bounds2 = /* @__PURE__ */ new Vector2();\n\n\tfunction coplanarIntersectsTriangle( self, other, target, suppressLog ) {\n\n\t\t// Perform separating axis intersection test only for coplanar triangles\n\t\t// There should be at least one non-degenerate triangle when calling this\n\t\t// Otherwise we won't know the plane normal\n\t\tconst planeNormal = tmpVec;\n\t\tif ( ! self.isDegenerateIntoPoint && ! self.isDegenerateIntoSegment ) {\n\n\t\t\tplaneNormal.copy( self.plane.normal );\n\n\t\t} else {\n\n\t\t\tplaneNormal.copy( other.plane.normal );\n\n\t\t}\n\n\t\tconst satBounds1 = self.satBounds;\n\t\tconst satAxes1 = self.satAxes;\n\t\tfor ( let i = 1; i < 4; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, other.points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\ttempDir.copy( planeNormal ).cross( sa );\n\t\t\tcachedSatBounds.setFromPoints( tempDir, self.points );\n\t\t\tcachedSatBounds2.setFromPoints( tempDir, other.points );\n\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t}\n\n\t\tconst satBounds2 = other.satBounds;\n\t\tconst satAxes2 = other.satAxes;\n\t\tfor ( let i = 1; i < 4; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, self.points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\ttempDir.crossVectors( planeNormal, sa );\n\t\t\tcachedSatBounds.setFromPoints( tempDir, self.points );\n\t\t\tcachedSatBounds2.setFromPoints( tempDir, other.points );\n\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t}\n\n\t\tif ( target ) {\n\n\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t}\n\n\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction findSingleBounds( a, b, c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge ) {\n\n\t\tlet t = aDist / ( aDist - bDist );\n\t\tbounds.x = aProj + ( bProj - aProj ) * t;\n\t\tedge.start.subVectors( b, a ).multiplyScalar( t ).add( a );\n\n\t\tt = aDist / ( aDist - cDist );\n\t\tbounds.y = aProj + ( cProj - aProj ) * t;\n\t\tedge.end.subVectors( c, a ).multiplyScalar( t ).add( a );\n\n\t}\n\n\t/**\n\t * Calculates intersection segment of a triangle with intersection line.\n\t * Intersection line is snapped to its biggest component.\n\t * And triangle points are passed as a projection on that component.\n\t * @returns whether this is a coplanar case or not\n\t */\n\tfunction findIntersectionLineBounds( self, aProj, bProj, cProj, abDist, acDist, aDist, bDist, cDist, bounds, edge ) {\n\n\t\tif ( abDist > 0 ) {\n\n\t\t\t// then bcDist < 0\n\t\t\tfindSingleBounds( self.c, self.a, self.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge );\n\n\t\t} else if ( acDist > 0 ) {\n\n\t\t\tfindSingleBounds( self.b, self.a, self.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge );\n\n\t\t} else if ( bDist * cDist > 0 || aDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.a, self.b, self.c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge );\n\n\t\t} else if ( bDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.b, self.a, self.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge );\n\n\t\t} else if ( cDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.c, self.a, self.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge );\n\n\t\t} else {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction intersectTriangleSegment( triangle, degenerateTriangle, target, suppressLog ) {\n\n\t\tconst segment = degenerateTriangle.degenerateSegment;\n\t\tconst startDist = triangle.plane.distanceToPoint( segment.start );\n\t\tconst endDist = triangle.plane.distanceToPoint( segment.end );\n\t\tif ( isNearZero( startDist ) ) {\n\n\t\t\tif ( isNearZero( endDist ) ) {\n\n\t\t\t\treturn coplanarIntersectsTriangle( triangle, degenerateTriangle, target, suppressLog );\n\n\t\t\t} else {\n\n\t\t\t\t// Is this fine to modify target even if there might be no intersection?\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( segment.start );\n\t\t\t\t\ttarget.end.copy( segment.start );\n\n\t\t\t\t}\n\n\t\t\t\treturn triangle.containsPoint( segment.start );\n\n\t\t\t}\n\n\t\t} else if ( isNearZero( endDist ) ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( segment.end );\n\t\t\t\ttarget.end.copy( segment.end );\n\n\t\t\t}\n\n\t\t\treturn triangle.containsPoint( segment.end );\n\n\t\t} else {\n\n\t\t\tif ( triangle.plane.intersectLine( segment, tmpVec ) != null ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( tmpVec );\n\t\t\t\t\ttarget.end.copy( tmpVec );\n\n\t\t\t\t}\n\n\t\t\t\treturn triangle.containsPoint( tmpVec );\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction intersectTrianglePoint( triangle, degenerateTriangle, target ) {\n\n\t\tconst point = degenerateTriangle.a;\n\n\t\tif ( isNearZero( triangle.plane.distanceToPoint( point ) ) && triangle.containsPoint( point ) ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( point );\n\t\t\t\ttarget.end.copy( point );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tfunction intersectSegmentPoint( segmentTri, pointTri, target ) {\n\n\t\tconst segment = segmentTri.degenerateSegment;\n\t\tconst point = pointTri.a;\n\n\t\tsegment.closestPointToPoint( point, true, tmpVec );\n\n\t\tif ( point.distanceToSquared( tmpVec ) < ZERO_EPSILON_SQR ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( point );\n\t\t\t\ttarget.end.copy( point );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tfunction handleDegenerateCases( self, other, target, suppressLog ) {\n\n\t\tif ( self.isDegenerateIntoSegment ) {\n\n\t\t\tif ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\t// TODO: replace with Line.distanceSqToLine3 after r179\n\t\t\t\tconst segment1 = self.degenerateSegment;\n\t\t\t\tconst segment2 = other.degenerateSegment;\n\t\t\t\tconst delta1 = dir1;\n\t\t\t\tconst delta2 = dir2;\n\t\t\t\tsegment1.delta( delta1 );\n\t\t\t\tsegment2.delta( delta2 );\n\t\t\t\tconst startDelta = tmpVec.subVectors( segment2.start, segment1.start );\n\n\t\t\t\tconst denom = delta1.x * delta2.y - delta1.y * delta2.x;\n\t\t\t\tif ( isNearZero( denom ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst t = ( startDelta.x * delta2.y - startDelta.y * delta2.x ) / denom;\n\t\t\t\tconst u = - ( delta1.x * startDelta.y - delta1.y * startDelta.x ) / denom;\n\n\t\t\t\tif ( t < 0 || t > 1 || u < 0 || u > 1 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst z1 = segment1.start.z + delta1.z * t;\n\t\t\t\tconst z2 = segment2.start.z + delta2.z * u;\n\n\t\t\t\tif ( isNearZero( z1 - z2 ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( segment1.start ).addScaledVector( delta1, t );\n\t\t\t\t\t\ttarget.end.copy( segment1.start ).addScaledVector( delta1, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\treturn intersectSegmentPoint( self, other, target );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersectTriangleSegment( other, self, target, suppressLog );\n\n\t\t\t}\n\n\t\t} else if ( self.isDegenerateIntoPoint ) {\n\n\t\t\tif ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\tif ( other.a.distanceToSquared( self.a ) < ZERO_EPSILON_SQR ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( self.a );\n\t\t\t\t\t\ttarget.end.copy( self.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\treturn intersectSegmentPoint( other, self, target );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersectTrianglePoint( other, self, target );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\treturn intersectTrianglePoint( self, other, target );\n\n\t\t\t} else if ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\treturn intersectTriangleSegment( self, other, target, suppressLog );\n\n\t\t\t} /* else this is a general triangle-traingle case, so return undefined */\n\n\t\t}\n\n\t}\n\n\t/* TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t * be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t *\n\t * General triangle intersection code is based on Moller's algorithm from here: https://web.stanford.edu/class/cs277/resources/papers/Moller1997b.pdf\n\t * Reference implementation from here: https://github.com/erich666/jgt-code/blob/master/Volume_08/Number_1/Shen2003/tri_tri_test/include/Moller97.c#L570\n\t * All degeneracies are handled before the general algorithm.\n\t * Coplanar check is different from Moller's and based on SAT tests.\n\t */\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst res = handleDegenerateCases( this, other, target, suppressLog );\n\t\tif ( res !== undefined ) {\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tlet a1Dist = plane2.distanceToPoint( this.a );\n\t\tlet b1Dist = plane2.distanceToPoint( this.b );\n\t\tlet c1Dist = plane2.distanceToPoint( this.c );\n\n\t\tif ( isNearZero( a1Dist ) )\n\t\t\ta1Dist = 0;\n\n\t\tif ( isNearZero( b1Dist ) )\n\t\t\tb1Dist = 0;\n\n\t\tif ( isNearZero( c1Dist ) )\n\t\t\tc1Dist = 0;\n\n\t\tconst a1b1Dist = a1Dist * b1Dist;\n\t\tconst a1c1Dist = a1Dist * c1Dist;\n\t\tif ( a1b1Dist > 0 && a1c1Dist > 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tlet a2Dist = plane1.distanceToPoint( other.a );\n\t\tlet b2Dist = plane1.distanceToPoint( other.b );\n\t\tlet c2Dist = plane1.distanceToPoint( other.c );\n\n\t\tif ( isNearZero( a2Dist ) )\n\t\t\ta2Dist = 0;\n\n\t\tif ( isNearZero( b2Dist ) )\n\t\t\tb2Dist = 0;\n\n\t\tif ( isNearZero( c2Dist ) )\n\t\t\tc2Dist = 0;\n\n\t\tconst a2b2Dist = a2Dist * b2Dist;\n\t\tconst a2c2Dist = a2Dist * c2Dist;\n\t\tif ( a2b2Dist > 0 && a2c2Dist > 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tdir1.copy( plane1.normal );\n\t\tdir2.copy( plane2.normal );\n\t\tconst intersectionLine = dir1.cross( dir2 );\n\n\t\tlet componentIndex = 0;\n\t\tlet maxComponent = Math.abs( intersectionLine.x );\n\t\tconst comp1 = Math.abs( intersectionLine.y );\n\t\tif ( comp1 > maxComponent ) {\n\n\t\t\tmaxComponent = comp1;\n\t\t\tcomponentIndex = 1;\n\n\t\t}\n\n\t\tconst comp2 = Math.abs( intersectionLine.z );\n\t\tif ( comp2 > maxComponent ) {\n\n\t\t\tcomponentIndex = 2;\n\n\t\t}\n\n\t\tconst key = componentKeys[ componentIndex ];\n\t\tconst a1Proj = this.a[ key ];\n\t\tconst b1Proj = this.b[ key ];\n\t\tconst c1Proj = this.c[ key ];\n\n\t\tconst a2Proj = other.a[ key ];\n\t\tconst b2Proj = other.b[ key ];\n\t\tconst c2Proj = other.c[ key ];\n\n\t\tif ( findIntersectionLineBounds( this, a1Proj, b1Proj, c1Proj, a1b1Dist, a1c1Dist, a1Dist, b1Dist, c1Dist, bounds1, edge1 ) ) {\n\n\t\t\treturn coplanarIntersectsTriangle( this, other, target, suppressLog );\n\n\t\t}\n\n\t\tif ( findIntersectionLineBounds( other, a2Proj, b2Proj, c2Proj, a2b2Dist, a2c2Dist, a2Dist, b2Dist, c2Dist, bounds2, edge2 ) ) {\n\n\t\t\treturn coplanarIntersectsTriangle( this, other, target, suppressLog );\n\n\t\t}\n\n\t\tif ( bounds1.y < bounds1.x ) {\n\n\t\t\tconst tmp = bounds1.y;\n\t\t\tbounds1.y = bounds1.x;\n\t\t\tbounds1.x = tmp;\n\n\t\t\ttempPoint.copy( edge1.start );\n\t\t\tedge1.start.copy( edge1.end );\n\t\t\tedge1.end.copy( tempPoint );\n\n\t\t}\n\n\t\tif ( bounds2.y < bounds2.x ) {\n\n\t\t\tconst tmp = bounds2.y;\n\t\t\tbounds2.y = bounds2.x;\n\t\t\tbounds2.x = tmp;\n\n\t\t\ttempPoint.copy( edge2.start );\n\t\t\tedge2.start.copy( edge2.end );\n\t\t\tedge2.end.copy( tempPoint );\n\n\t\t}\n\n\t\tif ( bounds1.y < bounds2.x || bounds2.y < bounds1.x ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( target ) {\n\n\t\t\tif ( bounds2.x > bounds1.x ) {\n\n\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t}\n\n\t\t\tif ( bounds2.y < bounds1.y ) {\n\n\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = /* @__PURE__ */ new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = /* @__PURE__ */ new Line3();\n\tconst line2 = /* @__PURE__ */ new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = /* @__PURE__ */ new ExtendedTriangle();\n\tconst pointsArr = /* @__PURE__ */ new Array( 3 );\n\tconst cachedSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedAxis = /* @__PURE__ */ new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, REVISION } from 'three';\n\nconst IS_GT_REVISION_169 = parseInt( REVISION ) >= 169;\nconst IS_LT_REVISION_161 = parseInt( REVISION ) <= 161;\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv1 );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv1 = res;\n\n\t\t\t}\n\n\t\t\tif ( IS_LT_REVISION_161 ) {\n\n\t\t\t\tintersection.uv2 = intersection.uv1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = new Vector3();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, intersection.normal );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.normal = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t\tif ( IS_GT_REVISION_169 ) {\n\n\t\t\tconst barycoord = new Vector3();\n\t\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\t\tintersection.barycoord = barycoord;\n\n\t\t}\n\n\t}\n\n\treturn intersection;\n\n}\n\nfunction getSide( materialOrSide ) {\n\n\treturn materialOrSide && materialOrSide.isMaterial ? materialOrSide.side : materialOrSide;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nexport function intersectTri( geometry, materialOrSide, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst { index, groups } = geometry;\n\tif ( geometry.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geometry.attributes;\n\tif ( Array.isArray( materialOrSide ) ) {\n\n\t\t// check which groups a triangle is present in and run the intersections\n\t\t// TODO: we shouldn't need to run and intersection test multiple times\n\t\tconst firstIndex = tri * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst { start, count, materialIndex } = groups[ i ];\n\t\t\tif ( firstIndex >= start && firstIndex < start + count ) {\n\n\t\t\t\tconst side = getSide( materialOrSide[ materialIndex ] );\n\t\t\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tintersection.faceIndex = tri;\n\t\t\t\t\tintersection.face.materialIndex = materialIndex;\n\n\t\t\t\t\tif ( intersections ) {\n\n\t\t\t\t\t\tintersections.push( intersection );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn intersection;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// run the intersection for the single material\n\t\tconst side = getSide( materialOrSide );\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tintersection.face.materialIndex = 0;\n\n\t\t\tif ( intersections ) {\n\n\t\t\t\tintersections.push( intersection );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n}\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract barycoord\n\tconst barycoord = target && target.barycoord ? target.barycoord : new Vector3();\n\tTriangle.getBarycoord( point, tempV1, tempV2, tempV3, barycoord );\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\t\ttarget.barycoord = barycoord;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv,\n\t\t\tbarycoord: barycoord,\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, materialOrSide, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\n\t\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, materialOrSide, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\n\t\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { BYTES_PER_NODE, UINT32_PER_NODE } from '../Constants.js';\n\nconst _bufferStack1 = /* @__PURE__ */ new BufferStack.constructor();\nconst _bufferStack2 = /* @__PURE__ */ new BufferStack.constructor();\nconst _boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\nconst _leftBox1 = /* @__PURE__ */ new Box3();\nconst _rightBox1 = /* @__PURE__ */ new Box3();\n\nconst _leftBox2 = /* @__PURE__ */ new Box3();\nconst _rightBox2 = /* @__PURE__ */ new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet nodeOffset1 = 0;\n\tlet nodeOffset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\tnodeOffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\tnodeOffset1, nodeOffset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\tnodeOffset2 += otherRoots[ j ].byteLength / BYTES_PER_NODE;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\tnodeOffset1 += roots[ i ].byteLength / BYTES_PER_NODE;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexOffset = 0,\n\tnode2IndexOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t// Note the \"nodeIndex\" values are just intended to be used as unique identifiers in the tree and\n\t\t// not used for accessing data\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3 } from 'three';\nimport { SKIP_GENERATION, DEFAULT_OPTIONS } from './Constants.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { ensureIndex, getRootPrimitiveRanges } from './build/geometryUtils.js';\nimport { BVH } from './BVH.js';\n\n// construct a new buffer that points to the set of triangles represented by the given ranges\nexport function generateIndirectBuffer( ranges, useSharedArrayBuffer ) {\n\n\tconst lastRange = ranges[ ranges.length - 1 ];\n\tconst useUint32 = lastRange.offset + lastRange.count > 2 ** 16;\n\n\t// use getRootIndexRanges which excludes gaps\n\tconst length = ranges.reduce( ( acc, val ) => acc + val.count, 0 );\n\tconst byteCount = useUint32 ? 4 : 2;\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( length * byteCount ) : new ArrayBuffer( length * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\n\t// construct a compact form of the triangles in these ranges\n\tlet index = 0;\n\tfor ( let r = 0; r < ranges.length; r ++ ) {\n\n\t\tconst { offset, count } = ranges[ r ];\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tindirectBuffer[ index + i ] = offset + i;\n\n\t\t}\n\n\t\tindex += count;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport class GeometryBVH extends BVH {\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn null;\n\n\t}\n\n\tget primitiveBufferStride() {\n\n\t\treturn this.indirect ? 1 : this.primitiveStride;\n\n\t}\n\tset primitiveBufferStride( v ) {}\n\n\tget primitiveBuffer() {\n\n\t\treturn this.indirect ? this._indirectBuffer : this.geometry.index.array;\n\n\t}\n\tset primitiveBuffer( v ) {}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'BVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'BVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'BVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tsuper();\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis.resolvePrimitiveIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\t\tthis._indirectBuffer = null;\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\t// build the BVH unless we're deserializing\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis.init( options );\n\n\t\t}\n\n\t}\n\n\tinit( options ) {\n\n\t\tconst { geometry, primitiveStride } = this;\n\n\t\tif ( options.indirect ) {\n\n\t\t\t// construct an buffer that is indirectly sorts the triangles used for the BVH\n\t\t\tconst ranges = getRootPrimitiveRanges( geometry, options.range, primitiveStride );\n\t\t\tconst indirectBuffer = generateIndirectBuffer( ranges, options.useSharedArrayBuffer );\n\t\t\tthis._indirectBuffer = indirectBuffer;\n\n\t\t} else {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\tsuper.init( options );\n\n\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t}\n\n\t}\n\n\t// Abstract methods to be implemented by subclasses\n\tcomputePrimitiveBounds( /* offset, count */ ) {\n\n\t\tthrow new Error( 'BVH: computePrimitiveBounds() not implemented' );\n\n\t}\n\n\tgetRootRanges( range ) {\n\n\t\t// TODO: can we avoid passing options in here\n\t\tif ( this.indirect ) {\n\n\t\t\treturn [ { offset: 0, count: this._indirectBuffer.length } ];\n\n\n\t\t} else {\n\n\t\t\treturn getRootPrimitiveRanges( this.geometry, range, this.primitiveStride );\n\n\t\t}\n\n\t}\n\n\traycastObject3D( /* object, raycaster, intersects = [] */ ) {\n\n\t\tthrow new Error( 'BVH: raycastObject3D() not implemented' );\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tlet {\n\t\t\titerateDirect,\n\t\t\titerateIndirect,\n\t\t\t...rest\n\t\t} = callbacks;\n\n\t\tconst selectedIterateFunc = this.indirect ? iterateIndirect : iterateDirect;\n\t\treturn super.shapecast( {\n\t\t\t...rest,\n\t\t\titerate: selectedIterateFunc,\n\t\t} );\n\n\t}\n\n}\n","import { BufferAttribute, FrontSide, Ray, Vector3, Matrix4 } from 'three';\nimport { SKIP_GENERATION, BYTES_PER_NODE, UINT32_PER_NODE, FLOAT32_EPSILON } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { IS_LEAF } from './utils/nodeBufferUtils.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nimport { GeometryBVH } from './GeometryBVH.js';\n\nconst _obb = /* @__PURE__ */ new OrientedBox();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _direction = /* @__PURE__ */ new Vector3();\nconst _InverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _worldScale = /* @__PURE__ */ new Vector3();\n\nexport class MeshBVH extends GeometryBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tconst result = {\n\t\t\tversion: 1,\n\t\t\troots: null,\n\t\t\tindex: null,\n\t\t\tindirectBuffer: null,\n\t\t};\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult.roots = rootData.map( root => root.slice() );\n\t\t\tresult.index = indexAttribute ? indexAttribute.array.slice() : null;\n\t\t\tresult.indirectBuffer = indirectBuffer ? indirectBuffer.slice() : null;\n\n\t\t} else {\n\n\t\t\tresult.roots = rootData;\n\t\t\tresult.index = indexAttribute ? indexAttribute.array : null;\n\t\t\tresult.indirectBuffer = indirectBuffer;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\n\t\t// handle backwards compatibility by fixing up the buffer roots\n\t\t// see issue gkjohnson/three-mesh-bvh#759\n\t\tif ( ! data.version ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH.deserialize: Serialization format has been changed and will be fixed up. ' +\n\t\t\t\t'It is recommended to regenerate any stored serialized data.'\n\t\t\t);\n\t\t\tfixupVersion0( roots );\n\n\t\t}\n\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t\t// convert version 0 serialized data (uint32 indices) to version 1 (node indices)\n\t\tfunction fixupVersion0( roots ) {\n\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\n\t\t\t\t// iterate over nodes and convert right child offsets\n\t\t\t\tfor ( let node = 0, l = root.byteLength / BYTES_PER_NODE; node < l; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( ! IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// convert absolute right child offset to relative offset\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] = uint32Array[ node32Index + 6 ] / UINT32_PER_NODE - node;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn 3;\n\n\t}\n\n\tget resolveTriangleIndex() {\n\n\t\treturn this.resolvePrimitiveIndex;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( options.maxLeafTris ) {\n\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tmaxLeafSize: options.maxLeafTris,\n\t\t\t};\n\n\t\t}\n\n\t\tsuper( geometry, options );\n\n\t}\n\n\t// implement abstract methods from BVH base class\n\tshiftTriangleOffsets( offset ) {\n\n\t\treturn super.shiftPrimitiveOffsets( offset );\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size count * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index (i - offset) * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tcomputePrimitiveBounds( offset, count, targetBuffer ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\tconst normalized = posAttr.normalized;\n\n\t\tif ( offset < 0 || count + offset - targetBuffer.offset > targetBuffer.length / 6 ) {\n\n\t\t\tthrow new Error( 'MeshBVH: compute triangle bounds range is invalid.' );\n\n\t\t}\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\t\tconst writeOffset = targetBuffer.offset;\n\n\t\t// iterate over the triangle range\n\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\tconst tri = indirectBuffer ? indirectBuffer[ i ] : i;\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst boundsIndexOffset = ( i - writeOffset ) * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\traycastObject3D( object, raycaster, intersects = [] ) {\n\n\t\tconst { material } = object;\n\t\tif ( material === undefined ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t_InverseMatrix.copy( object.matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _InverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( object.matrixWorld );\n\t\t_direction.copy( _ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = _direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tlet hit = this.raycastFirst( _ray, material, near, far );\n\t\t\thit = convertRaycastIntersect( hit, object, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = this.raycast( _ray, material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], object, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst intersects = [];\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\traycastFunc( this, i, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tlet closestResult = null;\n\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst result = raycastFirstFunc( this, i, materialOrSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst result = super.shapecast(\n\t\t\t{\n\t\t\t\t...callbacks,\n\t\t\t\tintersectsPrimitive: callbacks.intersectsTriangle,\n\t\t\t\tscratchPrimitive: triangle,\n\n\t\t\t\t// TODO: is the performance significant enough for the added complexity here?\n\t\t\t\t// can we just use one function?\n\t\t\t\titerateDirect: iterateOverTriangles,\n\t\t\t\titerateIndirect: iterateOverTriangles_indirect,\n\t\t\t}\n\t\t);\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\t_obb.set( box.min, box.max, boxToMesh );\n\t\t_obb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => _obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => _obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE, LEAFNODE_MASK_32 } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = LEAFNODE_MASK_32 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightNodeIndex = uint32Array[ nodeIndex32 + 6 ];\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightNodeIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = currNodeIndex + boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","import { BufferAttribute } from 'three';\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nexport function copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nexport function createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// Confirms that the two provided attributes are compatible. Returns false if they are not.\r\nexport function validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tif ( Boolean( attr1 ) !== Boolean( attr2 ) ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n","import { BufferAttribute, BufferGeometry } from 'three';\r\nimport { copyAttributeContents, createAttributeClone } from './BufferAttributeUtils.js';\r\n\r\nfunction validateMergeability( geometries ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tif ( ! geometries[ 0 ].getAttribute( 'position' ) ) {\r\n\r\n\t\tthrow new Error( 'StaticGeometryGenerator: position attribute is required.' );\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getTotalIndexCount( geometries ) {\r\n\r\n\tlet result = 0;\r\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\tresult += geometries[ i ].getIndex().count;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction getTotalAttributeCount( geometries ) {\r\n\r\n\tlet result = 0;\r\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\tresult += geometries[ i ].getAttribute( 'position' ).count;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction trimMismatchedAttributes( target, indexCount, attrCount ) {\r\n\r\n\tif ( target.index && target.index.count !== indexCount ) {\r\n\r\n\t\ttarget.setIndex( null );\r\n\r\n\t}\r\n\r\n\tconst attributes = target.attributes;\r\n\tfor ( const key in attributes ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\tif ( attr.count !== attrCount ) {\r\n\r\n\t\t\ttarget.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\r\nexport function mergeGeometries( geometries, options = {}, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst {\r\n\t\tuseGroups = false,\r\n\t\tforceUpdate = false,\r\n\t\tskipAssigningAttributes = [],\r\n\t\toverwriteIndex = true,\r\n\t} = options;\r\n\r\n\t// check if we can merge these geometries\r\n\tvalidateMergeability( geometries );\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst totalIndexCount = isIndexed ? getTotalIndexCount( geometries ) : - 1;\r\n\tconst totalAttributeCount = getTotalAttributeCount( geometries );\r\n\ttrimMismatchedAttributes( targetGeometry, totalIndexCount, totalAttributeCount );\r\n\r\n\t// set up groups\r\n\tif ( useGroups ) {\r\n\r\n\t\tlet offset = 0;\r\n\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst geometry = geometries[ i ];\r\n\r\n\t\t\tlet primitiveCount;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tprimitiveCount = geometry.getIndex().count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tprimitiveCount = geometry.getAttribute( 'position' ).count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, primitiveCount, i );\r\n\t\t\toffset += primitiveCount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate the final geometry\r\n\t// skip the assigning any attributes for items in the above array\r\n\tif ( isIndexed ) {\r\n\r\n\t\t// set up the index if it doesn't exist\r\n\t\tlet forceUpdateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( totalIndexCount ), 1, false ) );\r\n\t\t\tforceUpdateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( forceUpdateIndex || overwriteIndex ) {\r\n\r\n\t\t\t// copy the index data to the target geometry\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tconst targetIndex = targetGeometry.getIndex();\r\n\t\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.getIndex();\r\n\t\t\t\tconst skip = ! forceUpdate && ! forceUpdateIndex && skipAssigningAttributes[ i ];\r\n\t\t\t\tif ( ! skip ) {\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\t\ttargetIndex.setX( targetOffset + j, index.getX( j ) + indexOffset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetOffset += index.count;\r\n\t\t\t\tindexOffset += geometry.getAttribute( 'position' ).count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// copy all the attribute data over\r\n\tconst attributes = Object.keys( geometries[ 0 ].attributes );\r\n\tfor ( let i = 0, l = attributes.length; i < l; i ++ ) {\r\n\r\n\t\tlet forceUpdateAttr = false;\r\n\t\tconst key = attributes[ i ];\r\n\t\tif ( ! targetGeometry.getAttribute( key ) ) {\r\n\r\n\t\t\tconst firstAttr = geometries[ 0 ].getAttribute( key );\r\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( firstAttr, totalAttributeCount ) );\r\n\t\t\tforceUpdateAttr = true;\r\n\r\n\t\t}\r\n\r\n\t\tlet offset = 0;\r\n\t\tconst targetAttribute = targetGeometry.getAttribute( key );\r\n\t\tfor ( let g = 0, l = geometries.length; g < l; g ++ ) {\r\n\r\n\t\t\tconst geometry = geometries[ g ];\r\n\t\t\tconst skip = ! forceUpdate && ! forceUpdateAttr && skipAssigningAttributes[ g ];\r\n\t\t\tconst attr = geometry.getAttribute( key );\r\n \t\t\tif ( ! skip ) {\r\n\r\n\t\t\t\tif ( key === 'color' && targetAttribute.itemSize !== attr.itemSize ) {\r\n\r\n\t\t\t\t\t// make sure the color attribute is aligned with itemSize 3 to 4\r\n\t\t\t\t\tfor ( let index = offset, l = attr.count; index < l; index ++ ) {\r\n\r\n\t\t\t\t\t\tattr.setXYZW( index, targetAttribute.getX( index ), targetAttribute.getY( index ), targetAttribute.getZ( index ), 1.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\n\r\nexport function updateMaterialIndexAttribute( geometry, materials, allMaterials ) {\r\n\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = geometry.attributes.position;\r\n\tconst vertCount = posAttr.count;\r\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\r\n\tlet groups = geometry.groups;\r\n\tif ( groups.length === 0 ) {\r\n\r\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\r\n\r\n\t}\r\n\r\n\tlet materialIndexAttribute = geometry.getAttribute( 'materialIndex' );\r\n\tif ( ! materialIndexAttribute || materialIndexAttribute.count !== vertCount ) {\r\n\r\n\t\t// use an array with the minimum precision required to store all material id references.\r\n\t\tlet array;\r\n\t\tif ( allMaterials.length <= 255 ) {\r\n\r\n\t\t\tarray = new Uint8Array( vertCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray = new Uint16Array( vertCount );\r\n\r\n\t\t}\r\n\r\n\t\tmaterialIndexAttribute = new BufferAttribute( array, 1, false );\r\n\t\tgeometry.deleteAttribute( 'materialIndex' );\r\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\r\n\r\n\t}\r\n\r\n\tconst materialArray = materialIndexAttribute.array;\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst start = group.start;\r\n\t\tconst count = group.count;\r\n\t\tconst endCount = Math.min( count, totalCount - start );\r\n\r\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\r\n\t\tconst materialIndex = allMaterials.indexOf( mat );\r\n\r\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\r\n\r\n\t\t\tlet index = start + j;\r\n\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\tindex = indexAttr.getX( index );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialArray[ index ] = materialIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function setCommonAttributes( geometry, attributes ) {\r\n\r\n\tif ( ! geometry.index ) {\r\n\r\n\t\t// TODO: compute a typed array\r\n\t\tconst indexCount = geometry.attributes.position.count;\r\n\t\tconst array = new Array( indexCount );\r\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\r\n\r\n\t\t\tarray[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.setIndex( array );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\r\n\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.uv2 && ( attributes && attributes.includes( 'uv2' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tgeometry.setAttribute( 'uv2', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\r\n\r\n\t\t// compute tangents requires a uv and normal buffer\r\n\t\tif ( geometry.attributes.uv && geometry.attributes.normal ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.color && ( attributes && attributes.includes( 'color' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tconst array = new Float32Array( vertCount * 4 );\r\n\t\tarray.fill( 1.0 );\r\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( array, 4 ) );\r\n\r\n\t}\r\n\r\n}\r\n","// https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\r\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\nexport function bufferToHash( buffer ) {\r\n\r\n\tlet hash = 0;\r\n\r\n\tif ( buffer.byteLength !== 0 ) {\r\n\r\n\t\tconst uintArray = new Uint8Array( buffer );\r\n\t\tfor ( let i = 0; i < buffer.byteLength; i ++ ) {\r\n\r\n\t\t\tconst byte = uintArray[ i ];\r\n\t\t\thash = ( ( hash << 5 ) - hash ) + byte;\r\n\t\t\thash |= 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn hash;\r\n\r\n}\r\n","import { Matrix4 } from 'three';\r\nimport { bufferToHash } from '../../utils/bufferToHash.js';\r\n\r\nfunction getGeometryHash( geometry ) {\r\n\r\n\tlet hash = geometry.uuid;\r\n\tconst attributes = Object.values( geometry.attributes );\r\n\tif ( geometry.index ) {\r\n\r\n\t\tattributes.push( geometry.index );\r\n\t\thash += `index|${ geometry.index.version }`;\r\n\r\n\t}\r\n\r\n\tconst keys = Object.keys( attributes ).sort();\r\n\tfor ( const key of keys ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\thash += `${ key }_${ attr.version }|`;\r\n\r\n\t}\r\n\r\n\treturn hash;\r\n\r\n}\r\n\r\nfunction getSkeletonHash( mesh ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tif ( skeleton ) {\r\n\r\n\t\tif ( ! skeleton.boneTexture ) {\r\n\r\n\t\t\tskeleton.computeBoneTexture();\r\n\r\n\t\t}\r\n\r\n\t\t// we can't use the texture version here because it will change even\r\n\t\t// when the bones haven't\r\n\t\tconst dataHash = bufferToHash( skeleton.boneTexture.image.data.buffer );\r\n\t\treturn `${ dataHash }_${ skeleton.boneTexture.uuid }`;\r\n\r\n\t} else {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Checks whether the geometry changed between this and last evaluation\r\nexport class MeshDiff {\r\n\r\n\tconstructor( mesh = null ) {\r\n\r\n\t\tthis.matrixWorld = new Matrix4();\r\n\t\tthis.geometryHash = null;\r\n\t\tthis.skeletonHash = null;\r\n\t\tthis.primitiveCount = - 1;\r\n\r\n\t\tif ( mesh !== null ) {\r\n\r\n\t\t\tthis.updateFrom( mesh );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateFrom( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\r\n\t\tthis.geometryHash = getGeometryHash( geometry );\r\n\t\tthis.primitiveCount = primitiveCount;\r\n\t\tthis.skeletonHash = getSkeletonHash( mesh );\r\n\r\n\t}\r\n\r\n\tdidChange( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\r\n\t\tconst identical =\r\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\r\n\t\t\tthis.geometryHash === getGeometryHash( geometry ) &&\r\n\t\t\tthis.skeletonHash === getSkeletonHash( mesh ) &&\r\n\t\t\tthis.primitiveCount === primitiveCount;\r\n\r\n\t\treturn ! identical;\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferGeometry, Matrix3, Matrix4, Vector3, Vector4 } from 'three';\r\nimport { copyAttributeContents, createAttributeClone, validateAttributes } from './BufferAttributeUtils.js';\r\n\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\tconst bones = skeleton.bones;\r\n\tconst boneInverses = skeleton.boneInverses;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\ttarget.transformDirection( _matrix );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// inverts the geometry in place\r\nfunction invertGeometry( geometry ) {\r\n\r\n\tconst { index, attributes } = geometry;\r\n\tif ( index ) {\r\n\r\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\r\n\r\n\t\t\tconst v0 = index.getX( i );\r\n\t\t\tconst v2 = index.getX( i + 2 );\r\n\t\t\tindex.setX( i, v2 );\r\n\t\t\tindex.setX( i + 2, v0 );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attr = attributes[ key ];\r\n\t\t\tconst itemSize = attr.itemSize;\r\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\r\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\r\n\t\t\t\t\tattr.setComponent( i, j, v2 );\r\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\nexport function convertToStaticGeometry( mesh, options = {}, targetGeometry = new BufferGeometry() ) {\r\n\r\n\toptions = {\r\n\t\tapplyWorldTransforms: true,\r\n\t\tattributes: [],\r\n\t\t...options\r\n\t};\r\n\r\n\tconst geometry = mesh.geometry;\r\n\tconst applyWorldTransforms = options.applyWorldTransforms;\r\n\tconst includeNormal = options.attributes.includes( 'normal' );\r\n\tconst includeTangent = options.attributes.includes( 'tangent' );\r\n\tconst attributes = geometry.attributes;\r\n\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t// strip any unused and unneeded attributes\r\n\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\tif ( ! options.attributes.includes( key ) || ! ( key in geometry.attributes ) ) {\r\n\r\n\t\t\ttargetGeometry.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// initialize the attributes if they don't exist\r\n\tif ( ! targetGeometry.index && geometry.index ) {\r\n\r\n\t\ttargetGeometry.index = geometry.index.clone();\r\n\r\n\t}\r\n\r\n\tif ( ! targetAttributes.position ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t}\r\n\r\n\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t}\r\n\r\n\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t}\r\n\r\n\t// ensure the attributes are consistent\r\n\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\tif ( includeNormal ) {\r\n\r\n\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t}\r\n\r\n\tif ( includeTangent ) {\r\n\r\n\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t}\r\n\r\n\t// generate transformed vertex attribute data\r\n\tconst position = attributes.position;\r\n\tconst normal = includeNormal ? attributes.normal : null;\r\n\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\tconst morphPosition = geometry.morphAttributes.position;\r\n\tconst morphNormal = geometry.morphAttributes.normal;\r\n\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\tconst normalMatrix = new Matrix3();\r\n\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t// copy the index\r\n\tif ( geometry.index ) {\r\n\r\n\t\ttargetGeometry.index.array.set( geometry.index.array );\r\n\r\n\t}\r\n\r\n\t// copy and apply other attributes\r\n\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\tif ( normal ) {\r\n\r\n\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tangent ) {\r\n\r\n\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t}\r\n\r\n\t\t// apply morph target transform\r\n\t\tif ( morphInfluences ) {\r\n\r\n\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// apply bone transform\r\n\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\tmesh.applyBoneTransform( i, _positionVector );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update the vectors of the attributes\r\n\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\tif ( normal ) {\r\n\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tangent ) {\r\n\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// copy other attributes over\r\n\tfor ( const i in options.attributes ) {\r\n\r\n\t\tconst key = options.attributes[ i ];\r\n\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t}\r\n\r\n\tif ( mesh.matrixWorld.determinant() < 0 ) {\r\n\r\n\t\tinvertGeometry( targetGeometry );\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n","import { BufferGeometry } from 'three';\r\nimport { MeshDiff } from './MeshDiff.js';\r\nimport { convertToStaticGeometry } from './convertToStaticGeometry.js';\r\nimport { validateAttributes } from './BufferAttributeUtils.js';\r\n\r\nexport class BakedGeometry extends BufferGeometry {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.version = 0;\r\n\t\tthis.hash = null;\r\n\t\tthis._diff = new MeshDiff();\r\n\r\n\t}\r\n\r\n\t// returns whether the passed mesh is compatible with this baked geometry\r\n\t// such that it can be updated without resizing attributes\r\n\tisCompatible( mesh, attributes ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\r\n\r\n\t\t\tconst key = attributes[ i ];\r\n\t\t\tconst attr1 = geometry.attributes[ key ];\r\n\t\t\tconst attr2 = this.attributes[ key ];\r\n\t\t\tif ( attr1 && ! validateAttributes( attr1, attr2 ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tupdateFrom( mesh, options ) {\r\n\r\n\t\tconst diff = this._diff;\r\n\t\tif ( diff.didChange( mesh ) ) {\r\n\r\n\t\t\tconvertToStaticGeometry( mesh, options, this );\r\n\t\t\tdiff.updateFrom( mesh );\r\n\t\t\tthis.version ++;\r\n\t\t\tthis.hash = `${ this.uuid }_${ this.version }`;\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferAttribute, BufferGeometry, Mesh, MeshBasicMaterial } from 'three';\r\nimport { mergeGeometries } from './mergeGeometries.js';\r\nimport { setCommonAttributes } from './GeometryPreparationUtils.js';\r\nimport { BakedGeometry } from './BakedGeometry.js';\r\n\r\nexport const NO_CHANGE = 0;\r\nexport const GEOMETRY_ADJUSTED = 1;\r\nexport const GEOMETRY_REBUILT = 2;\r\n\r\n// iterate over only the meshes in the provided objects\r\nfunction flatTraverseMeshes( objects, cb ) {\r\n\r\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\tconst object = objects[ i ];\r\n\t\tobject.traverseVisible( o => {\r\n\r\n\t\t\tif ( o.isMesh ) {\r\n\r\n\t\t\t\tcb( o );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// return the set of materials used by the provided meshes\r\nfunction getMaterials( meshes ) {\r\n\r\n\tconst materials = [];\r\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\tconst mesh = meshes[ i ];\r\n\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn materials;\r\n\r\n}\r\n\r\nfunction mergeGeometryList( geometries, target, options ) {\r\n\r\n\t// If we have no geometry to merge then provide an empty geometry.\r\n\tif ( geometries.length === 0 ) {\r\n\r\n\t\t// if there are no geometries then just create a fake empty geometry to provide\r\n\t\ttarget.setIndex( null );\r\n\r\n\t\t// remove all geometry\r\n\t\tconst attrs = target.attributes;\r\n\t\tfor ( const key in attrs ) {\r\n\r\n\t\t\ttarget.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t\t// create dummy attributes\r\n\t\tfor ( const key in options.attributes ) {\r\n\r\n\t\t\ttarget.setAttribute( options.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tmergeGeometries( geometries, options, target );\r\n\r\n\t}\r\n\r\n\t// Mark all attributes as needing an update\r\n\tfor ( const key in target.attributes ) {\r\n\r\n\t\ttarget.attributes[ key ].needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( objects ) {\r\n\r\n\t\tthis.objects = null;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.generateMissingAttributes = true;\r\n\t\tthis.overwriteIndex = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Map();\r\n\t\tthis._geometryMergeSets = new WeakMap();\r\n\t\tthis._mergeOrder = [];\r\n\t\tthis._dummyMesh = null;\r\n\r\n\t\tthis.setObjects( objects || [] );\r\n\r\n\t}\r\n\r\n\t_getDummyMesh() {\r\n\r\n\t\t// return a consistent dummy mesh\r\n\t\tif ( ! this._dummyMesh ) {\r\n\r\n\t\t\tconst dummyMaterial = new MeshBasicMaterial();\r\n\t\t\tconst emptyGeometry = new BufferGeometry();\r\n\t\t\temptyGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( 9 ), 3 ) );\r\n\t\t\tthis._dummyMesh = new Mesh( emptyGeometry, dummyMaterial );\r\n\r\n\t\t}\r\n\r\n\t\treturn this._dummyMesh;\r\n\r\n\t}\r\n\r\n\t_getMeshes() {\r\n\r\n\t\t// iterate over only the meshes in the provided objects\r\n\t\tconst meshes = [];\r\n\t\tflatTraverseMeshes( this.objects, mesh => {\r\n\r\n\t\t\tmeshes.push( mesh );\r\n\r\n\t\t} );\r\n\r\n\t\t// Sort the geometry so it's in a reliable order\r\n\t\tmeshes.sort( ( a, b ) => {\r\n\r\n\t\t\tif ( a.uuid > b.uuid ) return 1;\r\n\t\t\tif ( a.uuid < b.uuid ) return - 1;\r\n\t\t\treturn 0;\r\n\r\n\t\t} );\r\n\r\n\t\tif ( meshes.length === 0 ) {\r\n\r\n\t\t\tmeshes.push( this._getDummyMesh() );\r\n\r\n\t\t}\r\n\r\n\t\treturn meshes;\r\n\r\n\t}\r\n\r\n\t_updateIntermediateGeometries() {\r\n\r\n\t\tconst { _intermediateGeometry } = this;\r\n\r\n\t\tconst meshes = this._getMeshes();\r\n\t\tconst unusedMeshKeys = new Set( _intermediateGeometry.keys() );\r\n\t\tconst convertOptions = {\r\n\t\t\tattributes: this.attributes,\r\n\t\t\tapplyWorldTransforms: this.applyWorldTransforms,\r\n\t\t};\r\n\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst meshKey = mesh.uuid;\r\n\t\t\tunusedMeshKeys.delete( meshKey );\r\n\r\n\t\t\t// initialize the intermediate geometry\r\n\t\t\t// if the mesh and source geometry have changed in such a way that they are no longer\r\n\t\t\t// compatible then regenerate the baked geometry from scratch\r\n\t\t\tlet geom = _intermediateGeometry.get( meshKey );\r\n\t\t\tif ( ! geom || ! geom.isCompatible( mesh, this.attributes ) ) {\r\n\r\n\t\t\t\tif ( geom ) {\r\n\r\n\t\t\t\t\tgeom.dispose();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeom = new BakedGeometry();\r\n\t\t\t\t_intermediateGeometry.set( meshKey, geom );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// transform the geometry into the intermediate buffer geometry, saving whether\r\n\t\t\t// or not it changed.\r\n\t\t\tif ( geom.updateFrom( mesh, convertOptions ) ) {\r\n\r\n\t\t\t\t// TODO: provide option for only generating the set of attributes that are present\r\n\t\t\t\t// and are in the attributes array\r\n\t\t\t\tif ( this.generateMissingAttributes ) {\r\n\r\n\t\t\t\t\tsetCommonAttributes( geom, this.attributes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tunusedMeshKeys.forEach( key => {\r\n\r\n\t\t\t_intermediateGeometry.delete( key );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tsetObjects( objects ) {\r\n\r\n\t\tif ( Array.isArray( objects ) ) {\r\n\r\n\t\t\tthis.objects = [ ...objects ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.objects = [ objects ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\r\n\t\tconst { useGroups, overwriteIndex, _intermediateGeometry, _geometryMergeSets } = this;\r\n\r\n\t\tconst meshes = this._getMeshes();\r\n\t\tconst skipAssigningAttributes = [];\r\n\t\tconst mergeGeometry = [];\r\n\t\tconst previousMergeInfo = _geometryMergeSets.get( targetGeometry ) || [];\r\n\r\n\t\t// update all the intermediate static geometry representations\r\n\t\tthis._updateIntermediateGeometries();\r\n\r\n\t\t// get the list of geometries to merge\r\n\t\tlet forceUpdate = false;\r\n\t\tif ( meshes.length !== previousMergeInfo.length ) {\r\n\r\n\t\t\tforceUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry.get( mesh.uuid );\r\n\t\t\tmergeGeometry.push( geom );\r\n\r\n\t\t\tconst info = previousMergeInfo[ i ];\r\n\t\t\tif ( ! info || info.uuid !== geom.uuid ) {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( false );\r\n\t\t\t\tforceUpdate = true;\r\n\r\n\t\t\t} else if ( info.version !== geom.version ) {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( false );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// If we have no geometry to merge then provide an empty geometry.\r\n\t\tmergeGeometryList( mergeGeometry, targetGeometry, { useGroups, forceUpdate, skipAssigningAttributes, overwriteIndex } );\r\n\r\n\t\t// force update means the attribute buffer lengths have changed\r\n\t\tif ( forceUpdate ) {\r\n\r\n\t\t\ttargetGeometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t\t_geometryMergeSets.set( targetGeometry, mergeGeometry.map( g => ( {\r\n\t\t\tversion: g.version,\r\n\t\t\tuuid: g.uuid,\r\n\t\t} ) ) );\r\n\r\n\t\tlet changeType = NO_CHANGE;\r\n\t\tif ( forceUpdate ) changeType = GEOMETRY_REBUILT;\r\n\t\telse if ( skipAssigningAttributes.includes( false ) ) changeType = GEOMETRY_ADJUSTED;\r\n\r\n\t\treturn {\r\n\t\t\tchangeType,\r\n\t\t\tmaterials: getMaterials( meshes ),\r\n\t\t\tgeometry: targetGeometry,\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferGeometry } from 'three';\r\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\r\nimport { StaticGeometryGenerator, NO_CHANGE, GEOMETRY_ADJUSTED, GEOMETRY_REBUILT } from './utils/StaticGeometryGenerator.js';\r\nimport { updateMaterialIndexAttribute } from './utils/GeometryPreparationUtils.js';\r\n\r\n// collect the textures from the materials\r\nfunction getTextures( materials ) {\r\n\r\n\tconst textureSet = new Set();\r\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\tconst material = materials[ i ];\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Array.from( textureSet );\r\n\r\n}\r\n\r\n// collect the lights in the scene\r\nfunction getLights( objects ) {\r\n\r\n\tconst lights = [];\r\n\tconst iesSet = new Set();\r\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\tobjects[ i ].traverse( c => {\r\n\r\n\t\t\tif ( c.visible ) {\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tc.isRectAreaLight ||\r\n\t\t\t\t\tc.isSpotLight ||\r\n\t\t\t\t\tc.isPointLight ||\r\n\t\t\t\t\tc.isDirectionalLight\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tlights.push( c );\r\n\r\n\t\t\t\t\tif ( c.iesMap ) {\r\n\r\n\t\t\t\t\t\tiesSet.add( c.iesMap );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tconst iesTextures = Array.from( iesSet ).sort( ( a, b ) => {\r\n\r\n\t\tif ( a.uuid < b.uuid ) return 1;\r\n\t\tif ( a.uuid > b.uuid ) return - 1;\r\n\t\treturn 0;\r\n\r\n\t} );\r\n\r\n\treturn { lights, iesTextures };\r\n\r\n}\r\n\r\nexport class PathTracingSceneGenerator {\r\n\r\n\tget initialized() {\r\n\r\n\t\treturn Boolean( this.bvh );\r\n\r\n\t}\r\n\r\n\tconstructor( objects ) {\r\n\r\n\t\t// options\r\n\t\tthis.bvhOptions = {};\r\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'color', 'uv', 'uv2' ];\r\n\t\tthis.generateBVH = true;\r\n\r\n\t\t// state\r\n\t\tthis.bvh = null;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( objects );\r\n\t\tthis._bvhWorker = null;\r\n\t\tthis._pendingGenerate = null;\r\n\t\tthis._buildAsync = false;\r\n\t\tthis._materialUuids = null;\r\n\r\n\t}\r\n\r\n\tsetObjects( objects ) {\r\n\r\n\t\tthis.staticGeometryGenerator.setObjects( objects );\r\n\r\n\t}\r\n\r\n\tsetBVHWorker( bvhWorker ) {\r\n\r\n\t\tthis._bvhWorker = bvhWorker;\r\n\r\n\t}\r\n\r\n\tasync generateAsync( onProgress = null ) {\r\n\r\n\t\tif ( ! this._bvhWorker ) {\r\n\r\n\t\t\tthrow new Error( 'PathTracingSceneGenerator: \"setBVHWorker\" must be called before \"generateAsync\" can be called.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.bvh instanceof Promise ) {\r\n\r\n\t\t\t// if a bvh is already being generated we can wait for that to finish\r\n\t\t\t// and build another with the latest data while sharing the results.\r\n\t\t\tif ( ! this._pendingGenerate ) {\r\n\r\n\t\t\t\tthis._pendingGenerate = new Promise( async () => {\r\n\r\n\t\t\t\t\tawait this.bvh;\r\n\t\t\t\t\tthis._pendingGenerate = null;\r\n\r\n\t\t\t\t\t// TODO: support multiple callbacks queued?\r\n\t\t\t\t\treturn this.generateAsync( onProgress );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this._pendingGenerate;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._buildAsync = true;\r\n\t\t\tconst result = this.generate( onProgress );\r\n\t\t\tthis._buildAsync = false;\r\n\r\n\t\t\tresult.bvh = this.bvh = await result.bvh;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( onProgress = null ) {\r\n\r\n\t\tconst { staticGeometryGenerator, geometry, attributes } = this;\r\n\t\tconst objects = staticGeometryGenerator.objects;\r\n\t\tstaticGeometryGenerator.attributes = attributes;\r\n\r\n\t\t// update the skeleton animations in case WebGLRenderer is not running\r\n\t\t// to update it.\r\n\t\tobjects.forEach( o => {\r\n\r\n\t\t\to.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isSkinnedMesh && c.skeleton ) {\r\n\r\n\t\t\t\t\tc.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\t// generate the geometry\r\n\t\tconst result = staticGeometryGenerator.generate( geometry );\r\n\t\tconst materials = result.materials;\r\n\t\tlet needsMaterialIndexUpdate = result.changeType !== NO_CHANGE || this._materialUuids === null || this._materialUuids.length !== length;\r\n\t\tif ( ! needsMaterialIndexUpdate ) {\r\n\r\n\t\t\tfor ( let i = 0, length = materials.length; i < length; i ++ ) {\r\n\r\n\t\t\t\tconst material = materials[ i ];\r\n\t\t\t\tif ( material.uuid !== this._materialUuids[ i ] ) {\r\n\r\n\t\t\t\t\tneedsMaterialIndexUpdate = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst textures = getTextures( materials );\r\n\t\tconst { lights, iesTextures } = getLights( objects );\r\n\t\tif ( needsMaterialIndexUpdate ) {\r\n\r\n\t\t\tupdateMaterialIndexAttribute( geometry, materials, materials );\r\n\t\t\tthis._materialUuids = materials.map( material => material.uuid );\r\n\r\n\t\t}\r\n\r\n\t\t// only generate a new bvh if the objects used have changed\r\n\t\tif ( this.generateBVH ) {\r\n\r\n\t\t\tif ( this.bvh instanceof Promise ) {\r\n\r\n\t\t\t\tthrow new Error( 'PathTracingSceneGenerator: BVH is already building asynchronously.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( result.changeType === GEOMETRY_REBUILT ) {\r\n\r\n\t\t\t\tconst bvhOptions = {\r\n\t\t\t\t\tstrategy: SAH,\r\n\t\t\t\t\tmaxLeafTris: 1,\r\n\t\t\t\t\tindirect: true,\r\n\t\t\t\t\tonProgress,\r\n\t\t\t\t\t...this.bvhOptions,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( this._buildAsync ) {\r\n\r\n\t\t\t\t\tthis.bvh = this._bvhWorker.generate( geometry, bvhOptions );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.bvh = new MeshBVH( geometry, bvhOptions );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( result.changeType === GEOMETRY_ADJUSTED ) {\r\n\r\n\t\t\t\tthis.bvh.refit();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tbvhChanged: result.changeType !== NO_CHANGE,\r\n\t\t\tbvh: this.bvh,\r\n\t\t\tneedsMaterialIndexUpdate,\r\n\t\t\tlights,\r\n\t\t\tiesTextures,\r\n\t\t\tgeometry,\r\n\t\t\tmaterials,\r\n\t\t\ttextures,\r\n\t\t\tobjects,\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class DynamicPathTracingSceneGenerator extends PathTracingSceneGenerator {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tconsole.warn( 'DynamicPathTracingSceneGenerator has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class PathTracingSceneWorker extends PathTracingSceneGenerator {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tconsole.warn( 'PathTracingSceneWorker has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\r\n\r\n\t}\r\n\r\n}\r\n","function uuidSort( a, b ) {\r\n\r\n\tif ( a.uuid < b.uuid ) return 1;\r\n\tif ( a.uuid > b.uuid ) return - 1;\r\n\treturn 0;\r\n\r\n}\r\n\r\n// we must hash the texture to determine uniqueness using the encoding, as well, because the\r\n// when rendering each texture to the texture array they must have a consistent color space.\r\nexport function getTextureHash( t ) {\r\n\r\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\r\n\r\n}\r\n\r\n// reduce the set of textures to just those with a unique source while retaining\r\n// the order of the textures.\r\nfunction reduceTexturesToUniqueSources( textures ) {\r\n\r\n\tconst sourceSet = new Set();\r\n\tconst result = [];\r\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\tconst tex = textures[ i ];\r\n\t\tconst hash = getTextureHash( tex );\r\n\t\tif ( ! sourceSet.has( hash ) ) {\r\n\r\n\t\t\tsourceSet.add( hash );\r\n\t\t\tresult.push( tex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function getIesTextures( lights ) {\r\n\r\n\tconst textures = lights.map( l => l.iesMap || null ).filter( t => t );\r\n\tconst textureSet = new Set( textures );\r\n\treturn Array.from( textureSet ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getTextures( materials ) {\r\n\r\n\tconst textureSet = new Set();\r\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\tconst material = materials[ i ];\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst textureArray = Array.from( textureSet );\r\n\treturn reduceTexturesToUniqueSources( textureArray ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getLights( scene ) {\r\n\r\n\tconst lights = [];\r\n\tscene.traverse( c => {\r\n\r\n\t\tif ( c.visible ) {\r\n\r\n\t\t\tif (\r\n\t\t\t\tc.isRectAreaLight ||\r\n\t\t\t\tc.isSpotLight ||\r\n\t\t\t\tc.isPointLight ||\r\n\t\t\t\tc.isDirectionalLight\r\n\t\t\t) {\r\n\r\n\t\t\t\tlights.push( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn lights.sort( uuidSort );\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\r\nimport { getTextureHash } from '../core/utils/sceneUpdateUtils.js';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nexport const MATERIAL_PIXELS = 47;\r\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\r\n\r\nclass MaterialFeatures {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n\tisUsed( feature ) {\r\n\r\n\t\treturn feature in this._features;\r\n\r\n\t}\r\n\r\n\tsetUsed( feature, used = true ) {\r\n\r\n\t\tif ( used === false ) {\r\n\r\n\t\t\tdelete this._features[ feature ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._features[ feature ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MaterialsTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\r\n\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.type = FloatType;\r\n\t\tthis.wrapS = ClampToEdgeWrapping;\r\n\t\tthis.wrapT = ClampToEdgeWrapping;\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.features = new MaterialFeatures();\r\n\r\n\t}\r\n\r\n\tupdateFrom( materials, textures ) {\r\n\r\n\t\tfunction getTexture( material, key, def = - 1 ) {\r\n\r\n\t\t\tif ( key in material && material[ key ] ) {\r\n\r\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\r\n\t\t\t\treturn textureLookUp[ hash ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn def;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getField( material, key, def ) {\r\n\r\n\t\t\treturn key in material ? material[ key ] : def;\r\n\r\n\t\t}\r\n\r\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\r\n\r\n\t\t\tconst texture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\r\n\r\n\t\t\t// check if texture exists\r\n\t\t\tif ( texture ) {\r\n\r\n\t\t\t\tif ( texture.matrixAutoUpdate ) {\r\n\r\n\t\t\t\t\ttexture.updateMatrix();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst elements = texture.matrix.elements;\r\n\r\n\t\t\t\tlet i = 0;\r\n\r\n\t\t\t\t// first row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t\t// second row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 8;\r\n\r\n\t\t}\r\n\r\n\t\tlet index = 0;\r\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\r\n\t\tconst { image, features } = this;\r\n\r\n\t\t// index the list of textures based on shareable source\r\n\t\tconst textureLookUp = {};\r\n\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\t\ttextureLookUp[ getTextureHash( textures[ i ] ) ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tif ( image.width !== dimension ) {\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\timage.width = dimension;\r\n\t\t\timage.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = image.data;\r\n\r\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\r\n\t\t// can't encode texture ids that way.\r\n\t\t// const intArray = new Int32Array( floatArray.buffer );\r\n\r\n\t\tfeatures.reset();\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst m = materials[ i ];\r\n\r\n\t\t\tif ( m.isFogVolumeMaterial ) {\r\n\r\n\t\t\t\tfeatures.setUsed( 'FOG' );\r\n\r\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\r\n\r\n\t\t\t\t\tfloatArray[ index + j ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sample 0 .rgb\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\r\n\r\n\t\t\t\t// sample 2 .a\r\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t\t// sample 3 .rgb\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\r\n\r\n\t\t\t\t// sample 13 .g\r\n\t\t\t\t// reusing opacity field\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\r\n\r\n\t\t\t\t// side\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\r\n\r\n\t\t\t\t// sample 14 .b\r\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\r\n\r\n\t\t\t\tindex += MATERIAL_STRIDE;\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 0\r\n\t\t\t// color\r\n\t\t\tfloatArray[ index ++ ] = m.color.r;\r\n\t\t\tfloatArray[ index ++ ] = m.color.g;\r\n\t\t\tfloatArray[ index ++ ] = m.color.b;\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\r\n\r\n\t\t\t// sample 1\r\n\t\t\t// metalness & roughness\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// transmission & emissiveIntensity\r\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t// sample 3\r\n\t\t\t// emission\r\n\t\t\tif ( 'emissive' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\r\n\r\n\t\t\t// sample 4\r\n\t\t\t// normals\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\r\n\t\t\tif ( 'normalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\r\n\r\n \t\t\t} else {\r\n\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n \t\t\t}\r\n\r\n\t\t\t// clearcoat\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\r\n\r\n\t\t\t// sample 6\r\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\r\n\r\n\t\t\t// sample 7\r\n\t\t\t// sheen\r\n\t\t\tif ( 'sheenColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\r\n\r\n\t\t\t// sample 8\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\r\n\r\n\t\t\t// iridescence\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\r\n\r\n\t\t\t// sample 9\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\r\n\r\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\r\n\r\n\t\t\t// sample 10\r\n\t\t\t// specular color\r\n\t\t\tif ( 'specularColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\r\n\r\n\t\t\t// sample 11\r\n\t\t\t// specular intensity\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\r\n\r\n\t\t\t// isThinFilm\r\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\r\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// sample 12\r\n\t\t\tif ( 'attenuationColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\r\n\r\n\t\t\t// sample 13\r\n\t\t\t// alphaMap\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\r\n\r\n\t\t\t// side & matte\r\n\t\t\tfloatArray[ index ++ ] = m.opacity;\r\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\r\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( m.side ) {\r\n\r\n\t\t\t\tcase FrontSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase BackSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase DoubleSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 14\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'matte', false ) ); // matte\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'castShadow', true ) ); // shadow\r\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ) | ( Number( getField( m, 'fogVolume', false ) ) << 2 ) | ( Number( getField( m, 'shadowReflectionCatcher', false ) ) << 3 ); // vertexColors, flatShading, fogVolume, shadowReflectionCatcher\r\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\r\n\r\n\t\t\t// map transform 15\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\r\n\r\n\t\t\t// metalnessMap transform 17\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\r\n\r\n\t\t\t// roughnessMap transform 19\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\r\n\r\n\t\t\t// transmissionMap transform 21\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\r\n\r\n\t\t\t// emissiveMap transform 22\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\r\n\r\n\t\t\t// normalMap transform 25\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatMap transform 27\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatNormalMap transform 29\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatRoughnessMap transform 31\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// sheenColorMap transform 33\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\r\n\r\n\t\t\t// sheenRoughnessMap transform 35\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceMap transform 37\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceThicknessMap transform 39\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\r\n\r\n\t\t\t// specularColorMap transform 41\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\r\n\r\n\t\t\t// specularIntensityMap transform 43\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\r\n\r\n\t\t\t// alphaMap transform 45\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'alphaMap', floatArray, index );\r\n\r\n\t\t}\r\n\r\n\t\t// check if the contents have changed\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","export const material_struct = /* glsl */ `\r\n\r\n\tstruct Material {\r\n\r\n\t\tvec3 color;\r\n\t\tint map;\r\n\r\n\t\tfloat metalness;\r\n\t\tint metalnessMap;\r\n\r\n\t\tfloat roughness;\r\n\t\tint roughnessMap;\r\n\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tint transmissionMap;\r\n\r\n\t\tfloat emissiveIntensity;\r\n\t\tvec3 emissive;\r\n\t\tint emissiveMap;\r\n\r\n\t\tint normalMap;\r\n\t\tvec2 normalScale;\r\n\r\n\t\tfloat clearcoat;\r\n\t\tint clearcoatMap;\r\n\t\tint clearcoatNormalMap;\r\n\t\tvec2 clearcoatNormalScale;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tint clearcoatRoughnessMap;\r\n\r\n\t\tint iridescenceMap;\r\n\t\tint iridescenceThicknessMap;\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThicknessMinimum;\r\n\t\tfloat iridescenceThicknessMaximum;\r\n\r\n\t\tvec3 specularColor;\r\n\t\tint specularColorMap;\r\n\r\n\t\tfloat specularIntensity;\r\n\t\tint specularIntensityMap;\r\n\t\tbool thinFilm;\r\n\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\tint alphaMap;\r\n\r\n\t\tbool castShadow;\r\n\t\tfloat opacity;\r\n\t\tfloat alphaTest;\r\n\r\n\t\tfloat side;\r\n\t\tbool matte;\r\n\t\tbool shadowReflectionCatcher;\r\n\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tint sheenColorMap;\r\n\t\tfloat sheenRoughness;\r\n\t\tint sheenRoughnessMap;\r\n\r\n\t\tbool vertexColors;\r\n\t\tbool flatShading;\r\n\t\tbool transparent;\r\n\t\tbool fogVolume;\r\n\r\n\t\tmat3 mapTransform;\r\n\t\tmat3 metalnessMapTransform;\r\n\t\tmat3 roughnessMapTransform;\r\n\t\tmat3 transmissionMapTransform;\r\n\t\tmat3 emissiveMapTransform;\r\n\t\tmat3 normalMapTransform;\r\n\t\tmat3 clearcoatMapTransform;\r\n\t\tmat3 clearcoatNormalMapTransform;\r\n\t\tmat3 clearcoatRoughnessMapTransform;\r\n\t\tmat3 sheenColorMapTransform;\r\n\t\tmat3 sheenRoughnessMapTransform;\r\n\t\tmat3 iridescenceMapTransform;\r\n\t\tmat3 iridescenceThicknessMapTransform;\r\n\t\tmat3 specularColorMapTransform;\r\n\t\tmat3 specularIntensityMapTransform;\r\n\t\tmat3 alphaMapTransform;\r\n\r\n\t};\r\n\r\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\r\n\r\n\t\tmat3 textureTransform;\r\n\r\n\t\tvec4 row1 = texelFetch1D( tex, index );\r\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\r\n\r\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\r\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\r\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\r\n\r\n\t\treturn textureTransform;\r\n\r\n\t}\r\n\r\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * uint( MATERIAL_PIXELS );\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\r\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\r\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\r\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\r\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\r\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\r\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\r\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\r\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\r\n\r\n\t\tMaterial m;\r\n\t\tm.color = s0.rgb;\r\n\t\tm.map = int( round( s0.a ) );\r\n\r\n\t\tm.metalness = s1.r;\r\n\t\tm.metalnessMap = int( round( s1.g ) );\r\n\t\tm.roughness = s1.b;\r\n\t\tm.roughnessMap = int( round( s1.a ) );\r\n\r\n\t\tm.ior = s2.r;\r\n\t\tm.transmission = s2.g;\r\n\t\tm.transmissionMap = int( round( s2.b ) );\r\n\t\tm.emissiveIntensity = s2.a;\r\n\r\n\t\tm.emissive = s3.rgb;\r\n\t\tm.emissiveMap = int( round( s3.a ) );\r\n\r\n\t\tm.normalMap = int( round( s4.r ) );\r\n\t\tm.normalScale = s4.gb;\r\n\r\n\t\tm.clearcoat = s4.a;\r\n\t\tm.clearcoatMap = int( round( s5.r ) );\r\n\t\tm.clearcoatRoughness = s5.g;\r\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\r\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\r\n\t\tm.clearcoatNormalScale = s6.rg;\r\n\r\n\t\tm.sheen = s6.a;\r\n\t\tm.sheenColor = s7.rgb;\r\n\t\tm.sheenColorMap = int( round( s7.a ) );\r\n\t\tm.sheenRoughness = s8.r;\r\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\r\n\r\n\t\tm.iridescenceMap = int( round( s8.b ) );\r\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\r\n\t\tm.iridescence = s9.r;\r\n\t\tm.iridescenceIor = s9.g;\r\n\t\tm.iridescenceThicknessMinimum = s9.b;\r\n\t\tm.iridescenceThicknessMaximum = s9.a;\r\n\r\n\t\tm.specularColor = s10.rgb;\r\n\t\tm.specularColorMap = int( round( s10.a ) );\r\n\r\n\t\tm.specularIntensity = s11.r;\r\n\t\tm.specularIntensityMap = int( round( s11.g ) );\r\n\t\tm.thinFilm = bool( s11.b );\r\n\r\n\t\tm.attenuationColor = s12.rgb;\r\n\t\tm.attenuationDistance = s12.a;\r\n\r\n\t\tm.alphaMap = int( round( s13.r ) );\r\n\r\n\t\tm.opacity = s13.g;\r\n\t\tm.alphaTest = s13.b;\r\n\t\tm.side = s13.a;\r\n\r\n\t\tm.matte = bool( s14.r );\r\n\t\tm.castShadow = bool( s14.g );\r\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\r\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\r\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\r\n\t\tm.shadowReflectionCatcher = bool( int( s14.b ) & 8 );\r\n\t\tm.transparent = bool( s14.a );\r\n\r\n\t\tuint firstTextureTransformIdx = i + 15u;\r\n\r\n\t\t// mat3( 1.0 ) is an identity matrix\r\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\r\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\r\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\r\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\r\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\r\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\r\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\r\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\r\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\r\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\r\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\r\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\r\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\r\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\r\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\r\n\t\tm.alphaMapTransform = m.alphaMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 30u );\r\n\r\n\t\treturn m;\r\n\r\n\t}\r\n\r\n`;\r\n","export const shape_sampling_functions = /* glsl */`\r\n\r\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\r\n\r\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\r\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\r\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\r\n\t\tfloat a = - 1.0 / ( sign + n.z );\r\n\t\tfloat b = n.x * n.y * a;\r\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\r\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\r\n\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat theta = 2.0 * PI * uv.y;\r\n\t\tfloat x = r * cos( theta );\r\n\t\tfloat y = r * sin( theta );\r\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\r\n\r\n\t}\r\n\r\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\r\n\r\n\t\t// get the edges of the triangle and the diagonal across the\r\n\t\t// center of the parallelogram\r\n\t\tvec2 e1 = a - b;\r\n\t\tvec2 e2 = c - b;\r\n\t\tvec2 diag = normalize( e1 + e2 );\r\n\r\n\t\t// pick the point in the parallelogram\r\n\t\tif ( r.x + r.y > 1.0 ) {\r\n\r\n\t\t\tr = vec2( 1.0 ) - r;\r\n\r\n\t\t}\r\n\r\n\t\treturn e1 * r.x + e2 * r.y;\r\n\r\n\t}\r\n\r\n\tvec2 sampleCircle( vec2 uv ) {\r\n\r\n\t\tfloat angle = 2.0 * PI * uv.x;\r\n\t\tfloat radius = sqrt( uv.y );\r\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\r\n\r\n\t}\r\n\r\n\tvec3 sampleSphere( vec2 uv ) {\r\n\r\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\r\n\t\tfloat t = uv.y * PI * 2.0;\r\n\t\tfloat f = sqrt( 1.0 - u * u );\r\n\r\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\r\n\r\n\t}\r\n\r\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\r\n\r\n\t\tsides = max( sides, 3 );\r\n\r\n\t\tvec3 r = uvw;\r\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\r\n\t\tfloat segment = floor( float( sides ) * r.x );\r\n\r\n\t\tfloat angle1 = anglePerSegment * segment;\r\n\t\tfloat angle2 = angle1 + anglePerSegment;\r\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\r\n\t\tvec2 b = vec2( 0.0, 0.0 );\r\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\r\n\r\n\t\treturn sampleTriangle( a, b, c, r.yz );\r\n\r\n\t}\r\n\r\n\t// samples an aperture shape with the given number of sides. 0 means circle\r\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\r\n\r\n\t\treturn blades == 0 ?\r\n\t\t\tsampleCircle( uvw.xy ) :\r\n\t\t\tsampleRegularPolygon( blades, uvw );\r\n\r\n\t}\r\n\r\n\r\n`;\r\n","export const pcg_functions = /* glsl */`\r\n\r\n\t// https://www.shadertoy.com/view/wltcRS\r\n\tuvec4 WHITE_NOISE_SEED;\r\n\r\n\tvoid rng_initialize( vec2 p, int frame ) {\r\n\r\n\t\t// white noise seed\r\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\r\n\r\n\t}\r\n\r\n\t// https://www.pcg-random.org/\r\n\tvoid pcg4d( inout uvec4 v ) {\r\n\r\n\t\tv = v * 1664525u + 1013904223u;\r\n\t\tv.x += v.y * v.w;\r\n\t\tv.y += v.z * v.x;\r\n\t\tv.z += v.x * v.y;\r\n\t\tv.w += v.y * v.z;\r\n\t\tv = v ^ ( v >> 16u );\r\n\t\tv.x += v.y*v.w;\r\n\t\tv.y += v.z*v.x;\r\n\t\tv.z += v.x*v.y;\r\n\t\tv.w += v.y*v.z;\r\n\r\n\t}\r\n\r\n\t// returns [ 0, 1 ]\r\n\tfloat pcgRand() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec2 pcgRand2() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\r\n\r\n\t}\r\n\r\n\tvec3 pcgRand3() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec4 pcgRand4() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\r\n\r\n\t}\r\n`;\r\n"],"names":["_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","Float32BufferAttribute","_geometry","FullScreenQuad","material","Mesh","renderer","value","CENTER","AVERAGE","SAH","CONTAINED","PRIMITIVE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","UINT32_PER_NODE","IS_LEAFNODE_FLAG","LEAFNODE_MASK_32","FLOAT32_EPSILON","SKIP_GENERATION","DEFAULT_OPTIONS","arrayToBox","nodeIndex32","array","target","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","i","dist","copyBounds","source","unionBounds","a","b","aVal","bVal","d","d3","expandByPrimitiveBounds","startIndex","primitiveBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","relativeOffset","SPLIT_AXIS","getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","boundsOffset","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","axis","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","c","bin","leftCacheBounds","rightCacheBounds","splitCount","bi","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","BVHNode","partition","buffer","stride","split","left","right","axisOffset","t0","l","r","tb","float32Array","uint8Array","MAX_POINTER","countNodes","node","populateBuffer","byteOffset","_populateBuffer","node32Index","node16Index","isLeaf","boundingData","splitAxis","leftByteOffset","rightByteOffset","currentNodeIndex","relativeRightIndex","buildTree","bvh","options","maxDepth","verbose","maxLeafSize","onProgress","partitionBuffer","partitionStride","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","triggerProgress","primitivesProcessed","depth","splitOffset","lstart","lcount","rstart","rcount","buildPackedTree","BufferConstructor","rootRanges","firstRange","lastRange","fullRange","range","nodeCount","PrimitivePool","getNewPrimitive","primitives","primitive","_BufferStack","stack","prevBuffer","BufferStack","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","nodeOffset","result","shapecastTraverse","length","geometry","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexOffset","nodeIndex16","getLeftOffset","getRightEndOffset","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","getVertexCount","geo","getTriCount","getIndexArray","vertexCount","ensureIndex","index","BufferAttribute","getFullPrimitiveRange","primitiveCount","drawRange","start","getPrimitiveGroupRanges","group","getRootPrimitiveRanges","primitiveRanges","ranges","drawRangeStart","drawRangeEnd","events","groupStart","groupCount","groupEnd","activeGroups","lastPos","event","newPos","tempBox","BVH","indirectBuffer","roots","rootIndex","totalNodes","callback","_traverse","callbacks","intersectsPrimitive","scratchPrimitive","iterate","originalIntersectsRange","contained","nodeIndex","shapecastFunc","SeparatingAxisBounds","points","field","min","max","val","p","other","Vector3","box","boxMin","boxMax","x","y","z","closestPointLineToLine","dir1","dir2","v02","l1","l2","v0","v10","v2","v32","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","p2","closestPoint","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","pp","componentKeys","ZERO_EPSILON","ZERO_EPSILON_SQR","isNearZero","ExtendedTriangle","Triangle","args","satAxes","satBounds","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","lengthAB","lengthBC","lengthCA","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","saTri2","cachedSatBounds","cachedSatBounds2","tmpVec","tempDir","edge1","edge2","tempPoint","bounds1","bounds2","coplanarIntersectsTriangle","self","suppressLog","planeNormal","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","findSingleBounds","aProj","bProj","cProj","aDist","bDist","cDist","t","findIntersectionLineBounds","abDist","acDist","intersectTriangleSegment","degenerateTriangle","startDist","endDist","intersectTrianglePoint","point","intersectSegmentPoint","segmentTri","pointTri","handleDegenerateCases","segment1","segment2","delta1","delta2","startDelta","u","z1","z2","res","plane1","plane2","a1Dist","b1Dist","c1Dist","a1b1Dist","a1c1Dist","a2Dist","b2Dist","c2Dist","a2b2Dist","a2c2Dist","intersectionLine","componentIndex","maxComponent","comp1","key","a1Proj","b1Proj","c1Proj","a2Proj","b2Proj","c2Proj","tmp","cornerFields","line1","line2","lineTarget","otherVec","thisVec","f11","f12","i2","f21","f22","OrientedBox","matrix","Matrix4","v","minVec","pi","alignedSatBounds","aabbBounds","saTri","pointsArr","cachedAxis","triSatBounds","triSatAxes","sa1","sa2","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","ExtendedTrianglePoolBase","ExtendedTrianglePool","closestPointToPoint","minThreshold","maxThreshold","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","tri","triIndex","closestDistance","IS_GT_REVISION_169","REVISION","IS_LT_REVISION_161","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkIntersection","ray","pA","pB","pC","side","near","far","intersect","BackSide","DoubleSide","distance","checkBufferGeometryIntersection","position","normal","uv","uv1","intersection","face","barycoord","getSide","materialOrSide","intersectTri","intersections","triOffset","groups","firstIndex","materialIndex","setTriangle","ta","tc","i0","intersectTris","_indirectBuffer","intersectClosestTri","iterateOverTriangles","intersectsTriangleFunc","refit","nodeIndices","indexArr","posAttr","force","forceChildren","includesLeft","includesRight","leftNodeId","rightNodeId","traverseLeft","traverseRight","leftChange","rightChange","didChange","left_i","right_i","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","intersectTris_indirect","vi","intersectClosestTri_indirect","iterateOverTriangles_indirect","raycast","intersects","_raycast","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","thisGeometry","thisIndex","thisPos","otherIndex","otherPos","otherTriangleCount","tempMatrix","temp3","temp4","closestPointToGeometry","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","triCount","refit_indirect","j","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","bvhcast","matrixToLocal","intersectsRanges","otherRoots","nodeOffset1","nodeOffset2","invMat","il","localBox","jl","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexOffset","node2IndexOffset","depth1","depth2","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","convertRaycastIntersect","hit","object","raycaster","isSharedArrayBufferSupported","convertToBufferType","ArrayConstructor","generateIndirectBuffer","useSharedArrayBuffer","useUint32","acc","byteCount","GeometryBVH","primitiveStride","iterateDirect","iterateIndirect","rest","selectedIterateFunc","_obb","_ray","Ray","_direction","_InverseMatrix","_worldScale","MeshBVH","rootData","indexAttribute","data","fixupVersion0","newIndex","targetBuffer","normalized","posArr","bufferOffset","getters","writeOffset","tri3","boundsIndexOffset","ai","ci","el","halfExtents","el2","scaleFactor","hits","FrontSide","raycastFunc","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","nodeIndex1","nodeIndex2","originalIntersectsRanges","boxToMesh","countToStringFormat","countToFormat","RedFormat","RGFormat","RGBAFormat","countToIntFormat","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","VertexAttributeTexture","DataTexture","NearestFilter","attr","overrideItemSize","originalItemSize","originalCount","itemSize","originalBufferCons","targetType","finalStride","FloatType","UnsignedIntType","IntType","type","format","normalizeValue","targetBufferCons","internalFormat","UnsignedByteType","ByteType","ShortType","UnsignedShortType","dimension","dataArray","originalNormalized","ii","UIntVertexAttributeTexture","FloatVertexAttributeTexture","MeshBVHUniformStruct","bvhToTextures","dereferenceIndex","bvhBounds","bvhContents","unpacked","indexArray","i3","v3","boundsTexture","contentsTexture","boundsDimension","boundsArray","contentsDimension","contentsArray","boundsIndex","mergedLeafCount","rightNodeIndex","common_functions","bvh_ray_functions","bvh_struct_definitions","copyAttributeContents","targetOffset","io","cons","createAttributeClone","countOverride","validateAttributes","attr1","attr2","sameCount","sameNormalized","sameType","sameItemSize","validateMergeability","geometries","isIndexed","attributesUsed","attributesCount","name","getTotalIndexCount","getTotalAttributeCount","trimMismatchedAttributes","indexCount","attrCount","attributes","mergeGeometries","targetGeometry","useGroups","forceUpdate","skipAssigningAttributes","overwriteIndex","totalIndexCount","totalAttributeCount","forceUpdateIndex","indexOffset","targetIndex","forceUpdateAttr","firstAttr","targetAttribute","g","skip","updateMaterialIndexAttribute","materials","allMaterials","indexAttr","vertCount","totalCount","materialIndexAttribute","materialArray","endCount","mat","setCommonAttributes","bufferToHash","hash","uintArray","byte","getGeometryHash","keys","getSkeletonHash","mesh","skeleton","MeshDiff","_positionVector","_normalVector","_tangentVector","_tangentVector4","Vector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","boneNormalTransform","bones","boneInverses","weight","boneIndex","addScaledMatrix","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","influence","morphAttribute","scale","targetArray","matrixArray","invertGeometry","convertToStaticGeometry","applyWorldTransforms","includeNormal","includeTangent","targetAttributes","tangent","morphPosition","morphNormal","morphTangent","normalMatrix","Matrix3","BakedGeometry","diff","NO_CHANGE","GEOMETRY_ADJUSTED","GEOMETRY_REBUILT","flatTraverseMeshes","objects","cb","o","getMaterials","meshes","mergeGeometryList","attrs","StaticGeometryGenerator","dummyMaterial","MeshBasicMaterial","emptyGeometry","_intermediateGeometry","unusedMeshKeys","convertOptions","meshKey","geom","_geometryMergeSets","mergeGeometry","previousMergeInfo","info","changeType","getTextures","textureSet","getLights","lights","iesSet","iesTextures","PathTracingSceneGenerator","bvhWorker","staticGeometryGenerator","needsMaterialIndexUpdate","textures","bvhOptions","uuidSort","getTextureHash","reduceTexturesToUniqueSources","sourceSet","tex","getIesTextures","textureArray","scene","MATERIAL_PIXELS","MATERIAL_STRIDE","MaterialFeatures","feature","used","MaterialsTexture","ClampToEdgeWrapping","getTexture","def","textureLookUp","getField","writeTextureMatrixToArray","textureKey","texture","elements","pixelCount","image","features","floatArray","m","iridescenceThicknessRange","isThinFilm","material_struct","shape_sampling_functions","pcg_functions"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA7BC,GAAqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECArCC,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]}